<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hexo 使用备忘</title>
    <url>/2020/09/20/Hexo-%E4%BD%BF%E7%94%A8%E5%A4%87%E5%BF%98/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>具体可以看：<a href="https://hexo.io/zh-cn/docs/">https://hexo.io/zh-cn/docs/</a></p>
<ul>
<li><p>安装node.js和npm</p>
</li>
<li><p>利用npm安装hexo</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建博客目录，以blog目录为例</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure>

<a id="more"></a>
</li>
<li><p>安装插件（包括上传github的，主题等等）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cd blog</span></span><br><span class="line">绘图类：<span class="comment">#npm install hexo-filter-mermaid-diagrams</span></span><br><span class="line">主题：<span class="comment">#git clone https://github.com/theme-next/hexo-theme-next themes/next</span></span><br><span class="line">上传github插件：<span class="comment">#npm install hexo-deployer-git</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>配置主题支持mermaid绘图插件<br>编辑next/_config.yml</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Mermaid tag</span></span><br><span class="line"><span class="attr">mermaid:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># Available themes: default | dark | forest | neutral</span></span><br><span class="line">  <span class="attr">theme:</span> <span class="string">forest</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>用法<br>靠标记符载入mermaid.js</p>
  <figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line">&#123;<span class="string">%</span> <span class="string">mermaid</span> <span class="string">type</span> <span class="string">%</span>&#125;</span><br><span class="line">&#123;<span class="string">%</span> <span class="string">endmermaid</span> <span class="string">%</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="attr">type :</span> <span class="string">type</span> <span class="string">of</span> <span class="string">the</span> <span class="string">mermaid</span> <span class="string">chart,</span> <span class="string">visit</span> <span class="string">https://github.com/mermaid-js/mermaid</span> <span class="string">for</span> <span class="string">more</span> <span class="string">information.</span></span><br></pre></td></tr></table></figure>

<p>例子：</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&#123;% mermaid graph TD %&#125;</span><br><span class="line">A[Hard] --&gt;|Text| B(Round)</span><br><span class="line">B --&gt; C&#123;Decision&#125;</span><br><span class="line">C --&gt;|One| D[Result 1]</span><br><span class="line">C --&gt;|Two| E[Result 2]</span><br><span class="line">&#123;% endmermaid %&#125;</span><br></pre></td></tr></table></figure>

<p><strong><em>mermaid详细教程</em></strong>： <a href="http://mermaid-js.github.io/mermaid/diagrams-and-syntax-and-examples/examples.html">http://mermaid-js.github.io/mermaid/diagrams-and-syntax-and-examples/examples.html</a></p>
<p><strong><em>typora图表介绍</em></strong>：<a href="https://support.typora.io/Draw-Diagrams-With-Markdown/">https://support.typora.io/Draw-Diagrams-With-Markdown/</a></p>
</li>
</ul>
<ul>
<li><p>各种命令</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">生成新博文：hexo n <span class="string">&quot;博文标题&quot;</span></span><br><span class="line">生成静态页面：hexo g</span><br><span class="line">开启本地服务：hexo s --debug</span><br><span class="line">上传github：hexo d</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="主题"><a href="#主题" class="headerlink" title="主题"></a>主题</h3><ul>
<li><p>仓库地址：<a href="https://github.com/next-theme/hexo-theme-next">https://github.com/next-theme/hexo-theme-next</a></p>
</li>
<li><p>教程地址：<a href="https://theme-next.js.org/docs/getting-started/">https://theme-next.js.org/docs/getting-started/</a></p>
</li>
</ul>
<h3 id="Hexo-添加分类及标签"><a href="#Hexo-添加分类及标签" class="headerlink" title="Hexo 添加分类及标签"></a>Hexo 添加分类及标签</h3><ul>
<li><p>创建“分类”选项<br>生成“分类”页并添加tpye属性,进入博客目录。执行命令下方命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p>添加type: “categories”到内容中，添加后是这样的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">分类</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-04-24 15:30:30</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">categories</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>给文章添加“categories”属性</p>
<p>打开需要添加分类的文章，为其添加categories属性。下方的categories:Hexo表示这篇文章添加到到“Hexo”这个分类。注意：一篇文章只会添加到一个分类中，如果是多个默认放到第一个分类中。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">添加分类及标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2017-05-26 12:12:57</span></span><br><span class="line"><span class="attr">categories:</span> <span class="string">Hexo</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>创建“标签”选项<br>生成“标签”页并添加tpye属性 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page tags</span><br></pre></td></tr></table></figure>
<p>添加type: “tags”到内容中，添加后是这样的：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-04-24 15:40:24</span></span><br><span class="line"><span class="attr">type:</span> <span class="string">tags</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>
<p>给文章添加“tags”属性,打开需要添加标签的文章，为其添加tags属性。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Hexo</span> <span class="string">添加分类及标签</span></span><br><span class="line"><span class="attr">date:</span> <span class="number">2019-04-24 15:40:24</span></span><br><span class="line"><span class="attr">categories:</span> </span><br><span class="line">           <span class="bullet">-</span> <span class="string">Hexo</span></span><br><span class="line"><span class="attr">tags:</span></span><br><span class="line">           <span class="bullet">-</span> <span class="string">博客</span></span><br><span class="line"><span class="meta">---</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="添加-RSS-订阅功能"><a href="#添加-RSS-订阅功能" class="headerlink" title="添加 RSS 订阅功能"></a>添加 RSS 订阅功能</h3><ul>
<li>安装插件：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-feed</span><br></pre></td></tr></table></figure></li>
<li>修改hexo的_config.yml，新增如下：<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Feed Atom</span></span><br><span class="line"><span class="attr">feed:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">atom</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">atom.xml</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">20</span></span><br></pre></td></tr></table></figure></li>
<li>修改主题_config.yml的Rss相关配置，打开开关即可。</li>
</ul>
<h3 id="关于typora插入图片后hexo生成路径问题"><a href="#关于typora插入图片后hexo生成路径问题" class="headerlink" title="关于typora插入图片后hexo生成路径问题"></a>关于typora插入图片后hexo生成路径问题</h3><ul>
<li>安装插件 hexo-image-link<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-image-link --save</span><br></pre></td></tr></table></figure></li>
<li>修改hexo的_config.yml<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post_asset_folder:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="其他：插入视频"><a href="#其他：插入视频" class="headerlink" title="其他：插入视频"></a>其他：插入视频</h3><p> 具体参考：<a href="https://hexo.io/docs/tag-plugins">https://hexo.io/docs/tag-plugins</a></p>
<ul>
<li>youtube<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% youtube video<span class="emphasis">_id [type] [cookie] %&#125;</span></span><br></pre></td></tr></table></figure>
例如:<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">&#123;% youtube lJIrF4YjHfQ %&#125;</span><br><span class="line">也可以插入播放列表</span><br><span class="line">&#123;% youtube PL9hW1uS6HUfscJ9DHkOSoOX45MjXduUxo &#x27;playlist&#x27; %&#125;</span><br></pre></td></tr></table></figure>
例子见：<a href="#">Post not found: hello-world</a></li>
</ul>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
        <tag>Next</tag>
      </tags>
  </entry>
  <entry>
    <title>MacOS使用记录</title>
    <url>/2020/08/30/MacOS%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h3 id="控制发热"><a href="#控制发热" class="headerlink" title="控制发热"></a>控制发热</h3><h4 id="双显卡策略"><a href="#双显卡策略" class="headerlink" title="双显卡策略"></a>双显卡策略</h4><ul>
<li>强制电池电源时使用核显(集成显卡)<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pmset -b GPUSwitch 0</span><br></pre></td></tr></table></figure></li>
<li>在插电时根据应用需求调用独立显卡<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo pmset -c GPUSwitch 2</span><br></pre></td></tr></table></figure>


</li>
</ul>
<a id="more"></a>

<h4 id="禁止睿频"><a href="#禁止睿频" class="headerlink" title="禁止睿频"></a>禁止睿频</h4><ul>
<li>安装turbo boost，创建一个脚本runtbs，内容：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo /Applications/Turbo\ Boost\ Switcher.app/Contents/MacOS/Turbo\ Boost\ Switcher</span><br></pre></td></tr></table></figure></li>
<li>然后赋予suid权限（即让普通用户可以启动）：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo chmod 4711 runtbs</span><br></pre></td></tr></table></figure></li>
<li>监控命令：<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo powermetrics</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="MUMU安卓模拟器连接问题"><a href="#MUMU安卓模拟器连接问题" class="headerlink" title="MUMU安卓模拟器连接问题"></a>MUMU安卓模拟器连接问题</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1.连接模拟器终端</span><br><span class="line">windows和mac不一样:</span><br><span class="line">【win版】</span><br><span class="line">adb connect 127.0.0.1:7555</span><br><span class="line">adb shell</span><br><span class="line">【mac版】</span><br><span class="line">adb kill-server &amp;&amp; adb server &amp;&amp; adb shell</span><br><span class="line"></span><br><span class="line">3.frida脱壳</span><br><span class="line">  a.到模拟器执行frida-server (https://github.com/frida/frida/releases)</span><br><span class="line">    传输server文件到模拟器：adb -s emulator-5554 push frida-server-12.11.14-android-x86 /data/</span><br><span class="line">  b.https://github.com/hluwa/FRIDA-DEXDump</span><br><span class="line">    安装：pip3 install frida-dexdump</span><br><span class="line">    执行：先在模拟器里运行需要脱壳的app，然后在主机执行frida-dexdump</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="PD虚拟机"><a href="#PD虚拟机" class="headerlink" title="PD虚拟机"></a>PD虚拟机</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先安装新版本 16.0.1(48919)，https://www.inpandora.com/parallels-desktop-13-3.html</span><br><span class="line">然后终端执行：sudo -b /Applications/Parallels\ Desktop.app/Contents/MacOS/prl_client_app</span><br></pre></td></tr></table></figure>



<h3 id="2k显示屏开启HIDPI"><a href="#2k显示屏开启HIDPI" class="headerlink" title="2k显示屏开启HIDPI"></a>2k显示屏开启HIDPI</h3><ul>
<li><p>关闭SIP</p>
<p>开机前按住command+r，直到logo出现松手，用终端输入csrutil disable，然后重启（可以用csrutil status检查一下</p>
</li>
</ul>
<p>使用一键脚本：<a href="https://github.com/xzhih/one-key-hidpi">https://github.com/xzhih/one-key-hidpi</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ioreg -l | grep <span class="string">&quot;DisplayVendorID&quot;</span></span><br><span class="line">  ioreg -l | grep <span class="string">&quot;DisplayProductID&quot;</span></span><br><span class="line">    | |   |           | | |         <span class="string">&quot;DisplayVendorID&quot;</span> = 1552   (macbook)</span><br><span class="line">    | |   |           | | | |       <span class="string">&quot;DisplayVendorID&quot;</span> = 4268     </span><br><span class="line">    | |   |           | | |         <span class="string">&quot;DisplayProductID&quot;</span> = 41028 (macbook)</span><br><span class="line">    | |   |           | | | |       <span class="string">&quot;DisplayProductID&quot;</span> = 53362</span><br></pre></td></tr></table></figure>



<h3 id="其他使用技巧"><a href="#其他使用技巧" class="headerlink" title="其他使用技巧"></a>其他使用技巧</h3><h4 id="输入法技巧"><a href="#输入法技巧" class="headerlink" title="输入法技巧"></a>输入法技巧</h4><p>详见官网：<a href="https://support.apple.com/zh-cn/guide/chinese-input-method/welcome/mac">https://support.apple.com/zh-cn/guide/chinese-input-method/welcome/mac</a></p>
<ul>
<li><p>切换输入法：control + 空格</p>
</li>
<li><p>翻页选词：可以不使用上下箭头，用[和]分别代替上翻和下翻；</p>
</li>
<li><p>拆字：比如要输入“淼”，可以先输入三个水：“水水水”，然后按shift+space即可调出拆字；</p>
</li>
<li><p>中英文、数字一次性混合输入：按住shift输入大写字母，按住option输入数字，练习这段文字：“C区7栋10楼D号房”；</p>
</li>
<li><p>输入声调：</p>
<ul>
<li>在英文输入法状态下，<strong>长按字母</strong>，会显示带拼音的字母选项，可以试试；</li>
<li>要在输入法设置里启用英文的“ABC扩展”，然后切换至该输入法，输入方法是option + aev<del>，后者a、e、v、</del>分别表示四声。输入的时候先输入声调，然后键入字母。练习：wǒ shì yí gè zhōng guó rén。</li>
</ul>
</li>
<li><p>拼音间隔：在元音之间加引号；</p>
</li>
<li><p>emoji：command + control + 空格。😂🤣🦊🚚🛵📷6️⃣🇮🇲👨‍👩‍👦☞➥</p>
</li>
<li><p>查找输入码<br>「查找输入码」功能简直就是一个学习拼音、五笔型、笔画的小帮手。你随便输入一组汉字，能看到每个字对应的拼音、五笔型、笔画以及拆字规则。点击输入法图标，选择「查找输入码」，或按「Option+Shift+L」即可打开输入码搜索框。</p>
</li>
<li><p>在 App 中，使用前缀键 (u)，键入字符（前面无需空格）的笔画输入码。例如，您可以键入以下内容：杓</p>
</li>
</ul>
<table>
<thead>
<tr>
<th align="left">拼音中的笔画</th>
<th align="left">键盘按键</th>
</tr>
</thead>
<tbody><tr>
<td align="left">一</td>
<td align="left">H</td>
</tr>
<tr>
<td align="left">丨</td>
<td align="left">S</td>
</tr>
<tr>
<td align="left">丿</td>
<td align="left">P</td>
</tr>
<tr>
<td align="left">丶(乀)</td>
<td align="left">N</td>
</tr>
<tr>
<td align="left">乛(乙)</td>
<td align="left">Z</td>
</tr>
<tr>
<td align="left">*通配符</td>
<td align="left">X</td>
</tr>
</tbody></table>
<p>  如果键入“unnzzsh”，则“字”会作为第一个候选字。</p>
<h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><ul>
<li>在程序间切换：command + tab，如果此时释放tab按住Q可以退出相应选中程序；</li>
<li>在本程序多窗口间切换：command + ~；</li>
<li>强制退出进程：command + option + esc；</li>
</ul>
]]></content>
      <categories>
        <category>Mac</category>
      </categories>
      <tags>
        <tag>Mac</tag>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo用例</title>
    <url>/2020/09/23/hexo%E7%94%A8%E4%BE%8B/</url>
    <content><![CDATA[<pre class="mermaid">graph TD
A[Hard] -->|Text| B(Round)
B --> C{Decision}
C -->|One| D[Result 1]
C -->|Two| E[Result 2]</pre>
<a id="more"></a>

<pre class="mermaid">graph TD
A[闹钟响起] --> B(与床板分离)
B --> C{分离成功?}
C --> |yes| D[快乐的一天]
C --> |no| B
B --> E[(数据库咯)]</pre>

<pre class="mermaid">pie
    title Key elements in Product X
    "Calcium" : 42.96
    "Potassium" : 50.05
    "Magnesium" : 10.01
    "Iron" :  5</pre>

<pre class="mermaid">classDiagram
      Animal <|-- Duck
      Animal <|-- Fish
      Animal <|-- Zebra
      Animal : +int age
      Animal : +String gender
      Animal: +isMammal()
      Animal: +mate()
      class Duck{
          +String beakColor
          +swim()
          +quack()
      }
      class Fish{
          -int sizeInFeet
          -canEat()
      }
      class Zebra{
          +bool is_wild
          +run()
      }</pre>


<pre class="mermaid">gantt
        dateFormat  YYYY-MM-DD
        title 快乐的生活
        section 吃一把鸡就学习
        学习            :done,    des1, 2014-01-06,2014-01-09
        疯狂学习               :active,  des2, 2014-01-09, 3d
        继续疯狂学习               :         des3, after des2, 5d
        吃鸡！               :         des4, after des3, 4d
        section 具体内容
        学习Python :crit, done, 2014-01-06,72h
        学习C++          :crit, done, after des1, 2d
        学习Lisp             :crit, active, 3d
        学习图形学        :crit, 4d
        跳伞           :2d
        打枪                      :2d</pre>

<pre class="mermaid">sequenceDiagram
李雷 ->> 韩梅梅: Hello 梅梅, How are you?
Note right of 韩梅梅: 韩梅梅心想
韩梅梅 -->> 李雷: I'm fine, thanks, and you?</pre>
<h3 id="插入图片和视频"><a href="#插入图片和视频" class="headerlink" title="插入图片和视频"></a>插入图片和视频</h3>

<div class="video-container"><iframe src="https://www.youtube.com/embed/U1eQfA3fXa4" frameborder="0" loading="lazy" allowfullscreen></iframe></div>
]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>关于阅读（转载）</title>
    <url>/2020/09/20/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB/</url>
    <content><![CDATA[<p><a href="https://mp.weixin.qq.com/s?__biz=MzI4NjMwNzU4OA==&mid=2247493372&idx=1&sn=9791b764cf4c9a2608716a39fe6cae68&chksm=ebdc4297dcabcb819219025e587a8ecf69efd61acb4e67e28a2b021e37bfe1fc7168655f052f&mpshare=1&scene=23&srcid=0919C6pT7zv6c0mEKhIbNvqq&sharer_sharetime=1600523057480&sharer_shareid=2493c0d635f685369899b4f3b0d7aac5%23rd">原文链接</a></p>
<h2 id="反复默写VS大量阅读"><a href="#反复默写VS大量阅读" class="headerlink" title="反复默写VS大量阅读"></a>反复默写VS大量阅读</h2><p>原创 高子阳 第一语文 <em>前天</em></p>
<p>为什么要默写？</p>
<p>是为了考试，为了高分，为了记住，还是为了素养？</p>
<p>对于一个班学生来说，为什么第一遍默写总是那几个同学全对，或者只有一点点小问题？为什么绝大多数同学要反反复复默写，还是难以全对？那些词，那些古诗文，那些段落到底怎么了？</p>
<a id="more"></a>

<p>研究默写，必须研究学生，研究学生的差异。其实，这一研究不难。那些第一遍默写就能全对或者只有一点点小问题的同学，早已经行走在“多读多写”的大道上了。也就是说，一个早已经爱上读写的学生，是不需要反反复复默写的。而研究那些反反复复还对不了的同学，几乎都不爱读爱写。</p>
<p>不得不说，反反复复地默写、订正，太伤害人了。多少学生，因为这种重复而讨厌语文。而这种默写得来的高分（仅仅限于小学），并不能确定是语文学习高手。看中高考语文成绩，这些年全国各地又有多少地方平均及格过？如此大量默写为何得不到应有的合格？</p>
<p>这其实就是我国多年中小学语文学习存在的问题——全国中小学生整体读书量太少，写作能力整体不行。</p>
<p>我在多次讲座中讲一张图、一组数据。</p>
<p>这张图是：</p>
<img src="/2020/09/20/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB/640-20200920214423649.jpeg" class="" title="img">

<p>每天小于一分钟读书，一年读8000个词；每天读4.6分钟，一年365天，认识词汇量达了282000个；每天读20分钟，其一年阅读量居然达到180万词。我国九年义务教育400万字的阅读量，也就是一天读4.8分钟。看这张图，把班级学生分为三类，哪类学生默写能做到一次全对，其实是非常明确的。我国绝大多数中小学生因为读书量不大，只在4.8分钟，所以想一次性默写好那是挺难的。</p>
<p>再来看看第二张表：</p>
<img src="/2020/09/20/%E5%85%B3%E4%BA%8E%E9%98%85%E8%AF%BB/640-20200920214423663.jpeg" class="" title="img">

<p>看看这张表，考50分的同学，每天读书4.6分钟，一年阅读词数是282000；考60分的同学，每天读书6.5分钟，一年阅读词数是432000；考90分的同学，每天读书21.1分钟，一年阅读词数1823000；考98分的同学，每天读书65分钟，一年阅读词数4358000。我国九年阅读量400万字，也就是处在每天读书4.6-6.5分之间，我国中高考多年语文整体平均分达不到及格，从这张表中可以找到原因。</p>
<p>大量默写能增加词汇量吗？每个学期，重来重去默写的那些词，就是二三百个字，一年也就五六百字，加上背诵课文的，一年很难超过1000个。这样的默写，怎么可能换来中高考的高分？如果说有效果，仅限于小学。因为小学的试卷是以考课本为主。有人会说，小学是基础，如果小学都不重视默写，中学语文质量会更差。持这种观点的人，肯定是懂教育教学规律的人，也不值得与这类人争辩。其实0-12岁的教育，大量阅读更为重要。</p>
<p>2012年，美国开始实施的全国性的教育大纲《各州共同核心标准》，该标准规定美国小学毕业生至少需要阅读1404本课外读物，阅读量占到全部K12年级阅读量的77.6%；美国《加州公立学校阅读/语言艺术大纲（K12）》规定小学一二年级用在阅读的时间是每天150分钟（在校）+（在家30或45分钟），这是全美最高标准。</p>
<p>我们现在所用的统编本教材，快乐读书吧六年才44本书！走进我们的中小学，看看课表上，有阅读课程吗？没有！看看课程表，4.8分钟的阅读都没有列在课程表上！这44本书，还有很多很多学生没有读的！</p>
<p>面对着默写，我们的思考视角该转变了。我们的语文教育教学如果能重视大量阅读，每天让孩子读1个小时书，那种死记硬背式的默写当然可以取消。取消了，语文成绩不仅不会降低，反而会大面积的提高。</p>
<p>当下，谁又会相信这一理论呢？因为佐藤学说：“他三十几年来，每周至少两天深入学校，扎根中小学实地观察。目前，他已到过全国3500多所学校，听了1万多节课。在学校改革中他遭遇许许多多次失败，从而认识到学校改革必须要从内而外进行改革，才能获得教育行政、政府、家长等的认可。因为家长是顽固，教师是顽固，学生是顽固的，校长更是顽固，教育主管部门就不要说了。一切都充满挑战！”这段话适合我们吗？有待研究。</p>
]]></content>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker macvlan使用记录</title>
    <url>/2020/11/23/Docker-macvlan%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="新建macvlan接口"><a href="#新建macvlan接口" class="headerlink" title="新建macvlan接口"></a>新建macvlan接口</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#新建macvlan网络</span></span><br><span class="line">docker network create -d macvlan -o parent=【eth0】 【eNet】 \</span><br><span class="line">--subnet=【Network IP】 \</span><br><span class="line">--ip-range=【IP Range】 \</span><br><span class="line">--gateway=【Gateway IP】</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line">docker network create -d macvlan -o parent=ovs_eth0 macnet --subnet=192.168.2.0/24 --ip-range=192.168.2.128/29 --gateway=192.168.2.1</span><br><span class="line"></span><br><span class="line">docker run -d   --name=qbittorrent  --network macnet -e PUID=1026   -e PGID=100   -e TZ=Asia/Shanghai   -e WEBUI_PORT=80   -v /volume1/docker/qbittorrent/config:/config   -v /volume1/downloads:/downloads/vol1   -v /volume2/downloads2:/downloads/vol2   -v /volume4/media:/downloads/vol4   --restart unless-stopped linuxserver/qbittorrent:amd64-latest</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<h4 id="Dockerfile："><a href="#Dockerfile：" class="headerlink" title="Dockerfile："></a>Dockerfile：</h4><figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">FROM debian:latest</span><br><span class="line">COPY start.sh torrc /tmp/</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get -y install openssh-server tor cron sudo rsyslog \</span><br><span class="line">	&amp;&amp; rm -rf /var/lib/apt/lists/* \</span><br><span class="line">    &amp;&amp; cat /tmp/torrc &gt;&gt; /etc/tor/torrc \</span><br><span class="line">	&amp;&amp; chmod +x /tmp/start.sh \</span><br><span class="line">	&amp;&amp; useradd -d /home/jervis -M -s /bin/bash -g root -G sudo jervis \</span><br><span class="line">	&amp;&amp; echo <span class="string">&quot;root:1&quot;</span>|chpasswd \</span><br><span class="line">	&amp;&amp; echo <span class="string">&quot;jervis:1&quot;</span>|chpasswd</span><br><span class="line"></span><br><span class="line">ENTRYPOINT [<span class="string">&quot;/bin/sh&quot;</span>, <span class="string">&quot;/tmp/start.sh&quot;</span>]</span><br></pre></td></tr></table></figure>
<p>torrc</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ControlPort 9051</span><br><span class="line">HashedControlPassword 16:876313025F85703C60CD9BCDFA1AE88349D9C67D23C97B6754649ADD05</span><br><span class="line"></span><br><span class="line">StrictNodes  1</span><br><span class="line"><span class="comment">#ExcludeNodes  &#123;cn&#125;,&#123;hk&#125;,&#123;mo&#125;</span></span><br><span class="line"><span class="comment">#ExitNodes &#123;jp&#125;,&#123;tw&#125;,&#123;sg&#125;,&#123;my&#125;</span></span><br><span class="line">ExitNodes &#123;at&#125;,&#123;jp&#125;,&#123;tw&#125;,&#123;sg&#125;,&#123;my&#125;</span><br></pre></td></tr></table></figure>



<p>start.sh</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">service rsyslog start</span><br><span class="line">service ssh start</span><br><span class="line">service cron start</span><br><span class="line">service tor start</span><br><span class="line"></span><br><span class="line"><span class="comment">#su - jervis -c &quot;cd /backup/media/api/spiders/mitmproxy &amp;&amp; nohup sh run.sh &gt; /dev/null 2&gt;&amp;1 &amp;&quot;</span></span><br><span class="line"><span class="comment">#su - jervis -c &quot;aria2c -D --conf ~/.aria2/aria2rpc.conf&quot;</span></span><br><span class="line">touch /var/<span class="built_in">log</span>/docker.log</span><br><span class="line">tail -f /var/<span class="built_in">log</span>/docker.log</span><br></pre></td></tr></table></figure>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker build -t spideros .</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d --restart always --name spiderDebian --hostname gingerOS --privileged --network macnet --ip 192.168.2.20  -v /volume3/backup:/backup -v /volume1/docker/spider-debian:/home/jervis -v /volume1/web:/web spideros</span><br></pre></td></tr></table></figure>

<h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ol>
<li>某些服务无法重启动，比如service xxx stop无法停止：可能是无权限读取/proc内cwd, exe文件，docker用高权限(–privileged)启动即可;</li>
</ol>
<h4 id="后续完善"><a href="#后续完善" class="headerlink" title="后续完善"></a>后续完善</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">时区：</span><br><span class="line">dpkg-reconfigure tzdata</span><br><span class="line">编码：</span><br><span class="line">apt install locales &amp;&amp; dpkg-reconfigure locales</span><br></pre></td></tr></table></figure>

<h4 id="修改已经存在的容器配置"><a href="#修改已经存在的容器配置" class="headerlink" title="修改已经存在的容器配置"></a>修改已经存在的容器配置</h4><p>先docker inspect 容器id，查看配置路径，比如修改hostname，可以执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker inspect 容器id | grep -i hostname</span><br></pre></td></tr></table></figure>

<p>取得容器目录，进入目录，修改config.v2.json，然后记得重启docker服务就会生效。</p>
]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>vim使用技巧</title>
    <url>/2020/10/02/vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h4 id="vim中delete（backspace）键不能向左删除"><a href="#vim中delete（backspace）键不能向左删除" class="headerlink" title="vim中delete（backspace）键不能向左删除"></a>vim中delete（backspace）键不能向左删除</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">VIM使用了 compatible 模式，或者把 backspace 变量设置为空了…其实compatible模式是VIM为了兼容vi而出现的配置，它的作用是使VIM的操作行为和规范和vi一致，而这种模式下backspace配置是空的。即意味着backspace无法删除 indent ， end of line ， start 这三种字符。</span><br></pre></td></tr></table></figure>



<p>在默认状态下，delete（backspace）按下只会删除本次插入模式下插入的文本，这跟backspace的模式设置有关，其模式可以设置为以下三种模式：</p>
<ul>
<li>0 same as “:set backspace=” (Vi compatible)</li>
<li>1 same as “:set backspace=indent,eol”</li>
<li>2 same as “:set backspace=indent,eol,start”</li>
</ul>
<h5 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h5><p>知道了原因，就好解决了，只需要将backspace的模式设置成2就可以了，在<code>~/.vimrc</code>中添加了一下内容，保存，下次进入vim就可以在插入模式下任意使用delete（backspace）键了：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot; 解决插入模式下delete/backspce键失效问题</span></span><br><span class="line"><span class="string">set backspace=2</span></span><br></pre></td></tr></table></figure>

<a id="more"></a>]]></content>
      <categories>
        <category>编辑器</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>各科学期小结</title>
    <url>/2020/10/14/%E5%90%84%E7%A7%91%E5%AD%A6%E6%9C%9F%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<h4 id="语文学习"><a href="#语文学习" class="headerlink" title="语文学习"></a>语文学习</h4><ul>
<li><p>历史故事听、读，全面铺开，“大语文”适合对历史有个    总体认识后的孩子，用来对之前所学知识的比对和拓展；</p>
</li>
<li><p>课本涉及到作品时代、人物背景的，最好能先提前了解；</p>
</li>
<li><p>课本预习：</p>
<ul>
<li>简单朗读、听课文音频、生字临摹</li>
</ul>
</li>
<li><p>地理知识</p>
</li>
</ul>
<a id="more"></a>

<h4 id="英语学习"><a href="#英语学习" class="headerlink" title="英语学习"></a>英语学习</h4><ul>
<li>分级RAZ</li>
<li>app:<ul>
<li>BBC learning English</li>
<li>ABA English</li>
<li></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>学习</category>
      </categories>
      <tags>
        <tag>study</tag>
      </tags>
  </entry>
  <entry>
    <title>恶魔奶爸英语学习方法（转）</title>
    <url>/2020/10/26/%E6%81%B6%E9%AD%94%E5%A5%B6%E7%88%B8%E8%8B%B1%E8%AF%AD%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%EF%BC%88%E8%BD%AC%EF%BC%89/</url>
    <content><![CDATA[<p>原文链接: <a href="https://reishin.me/learn-english/">https://reishin.me/learn-english/</a></p>
<h2 id="英语学习导论"><a href="#英语学习导论" class="headerlink" title="英语学习导论"></a>英语学习导论</h2><ul>
<li>大量输入理论：靠量的积累，通过不同的语料，每天坚持</li>
<li><code>i + 1</code> 理论：在输入时要循序渐进，根据个人水平，增加一些难度</li>
</ul>
<a id="more"></a>

<h2 id="英语学习误区"><a href="#英语学习误区" class="headerlink" title="英语学习误区"></a>英语学习误区</h2><p><strong>神功大力丸思想</strong></p>
<p>错误思想：</p>
<ul>
<li>试图以一种简单策略来解决所有的英语问题</li>
<li>妄图以一套教材来解决英语学习的所有阶段的所有问题（新概念学完全套对阅读和语法帮助很大）</li>
<li>一定要在某种方法和达到某种水平之间建立因果关系</li>
<li>坚持一切以考试为核心，考前突击万事大吉</li>
<li>口语优先万能</li>
<li>口音标准纯正至上</li>
<li>语法无用论</li>
</ul>
<p>正确思想：</p>
<ul>
<li>在学习过程中，需要输入大量的听力和阅读材料</li>
<li>需要认真分析所处的水平基础和学习阶段</li>
<li>灵活选择不同的教材跟不同的方法策略</li>
</ul>
<h2 id="英语学习的基本原理"><a href="#英语学习的基本原理" class="headerlink" title="英语学习的基本原理"></a>英语学习的基本原理</h2><h3 id="如何学会方言母语"><a href="#如何学会方言母语" class="headerlink" title="如何学会方言母语"></a>如何学会方言母语</h3><p>开口说方言所经历的几个阶段：</p>
<ul>
<li>一张白纸阶段</li>
<li>环境浸入阶段</li>
<li>父母教导阶段</li>
<li>牙牙学语阶段</li>
<li>流利阶段</li>
</ul>
<h3 id="如何学会普通话"><a href="#如何学会普通话" class="headerlink" title="如何学会普通话"></a>如何学会普通话</h3><p>语言学习和训练，最重要的是实证，而不是所谓的科学原理。</p>
<ol>
<li>全国绝大部分电视台，全部使用普通话，而且绝大多数节目，都配有中文字幕<ul>
<li>只有海量的输入，才可以轻松轻松地听懂一种不熟悉的语音系统</li>
</ul>
</li>
<li>从最简单的字词重复开始慢慢认字，非常重视老师领读</li>
<li>重要的启蒙方法，学习汉语拼音和拼读</li>
<li>重视大声朗读</li>
<li>语文课堂上基本都用普通话来交流</li>
<li>上大学后，以普通话作为使用语言</li>
<li>语文成绩好，阅读量最重要</li>
</ol>
<h3 id="英语学习成功案例分析"><a href="#英语学习成功案例分析" class="headerlink" title="英语学习成功案例分析"></a>英语学习成功案例分析</h3><ol>
<li>家境基本都极好，英文能力和家境直接成正比<ol>
<li>上得起昂贵的培训班</li>
<li>和地域、父母素质关系很大</li>
</ol>
</li>
<li>没有人完全靠纯自学，基本都有良好的启蒙机会或者名师点拨</li>
<li>度过了入门期后，想成为高手，就一定且必须只能靠自学</li>
<li>所有的英语流利者，都非常注重一个练习方法，反复听和反复模仿</li>
<li>想通过考试，想写作有水平就必须学语法</li>
<li>都非常重视大量阅读<ol>
<li>从最简单的简易读物开始读起，一直读到英文原版</li>
<li>大量阅读对口语有潜移默化的影响</li>
</ol>
</li>
<li>绝大部分高手都是英语专业或是文学专业</li>
</ol>
<h2 id="英语学习的基本原则和注意事项"><a href="#英语学习的基本原则和注意事项" class="headerlink" title="英语学习的基本原则和注意事项"></a>英语学习的基本原则和注意事项</h2><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul>
<li>刻意训练非常重要（刻意投入，集中注意力，理解吸收）</li>
<li>听力训练是刻意练习的第一步，也是最重要的一步<ul>
<li>听懂各种材料的能力，和你的口语跟写作水平关联非常大</li>
<li>听力能力是根，口语能力是叶</li>
<li>无法理解就做不到刻意练习</li>
</ul>
</li>
<li>一壶烧不开的水——持续不断的努力最重要<ul>
<li>一门技能的熟练和精通都意味着大脑需要建立数量庞大的神经元链接，这个过程需要漫长持久的训练</li>
<li>持续训练，而且必须是有意识集中精力的训练，否则就是无效输入</li>
<li>有四级基础的人，从慢速英语到常速英语，每天一两个小时，大约需要 90 天；在常速英语里可以输入，大约需要 180 天以上</li>
<li>英语学习如果不能一鼓作气，那么不如彻底放弃</li>
<li>选方法不如选材料，互联网是学习者的福音</li>
</ul>
</li>
</ul>
<h3 id="基本原则"><a href="#基本原则" class="headerlink" title="基本原则"></a>基本原则</h3><ul>
<li><p>集中注意力，刻意练习</p>
<ul>
<li>时间管理（30 分钟走神，果断停下）</li>
<li>方法采用（提高注意力的方法）</li>
<li>材料选择（材料过难难以跟上，换简单材料开始）</li>
</ul>
</li>
<li><p>保证大块时间投入</p>
<ul>
<li>只靠零碎时间你永远学不好英语，因为不能保证足够的语料输入</li>
</ul>
</li>
<li><p>纠结细节完全没有意义，重点在于流程规划和推进</p>
<ul>
<li>选择适合自己水平的材料</li>
<li>训练状态是集中注意力的</li>
<li>平时有意识地提高级别推动学习流程</li>
</ul>
</li>
<li><pre><code>i + 1</code></pre>
</li>
</ul>
<p>  原则</p>
<ul>
<li>选择材料要有一点挑战性</li>
<li>要主动有意识地升级</li>
</ul>
<ul>
<li><p>大量输入的同时重视规则学习</p>
<ul>
<li>对于发音细节和连续规则方面的系统学习和模仿</li>
<li>对语法大框架和构造句子规则的掌控</li>
</ul>
</li>
</ul>
<h2 id="英语学习入门"><a href="#英语学习入门" class="headerlink" title="英语学习入门"></a>英语学习入门</h2><h3 id="零基础阶段"><a href="#零基础阶段" class="headerlink" title="零基础阶段"></a>零基础阶段</h3><ol>
<li>一定要有好的启蒙老师</li>
<li>一定要学习音标</li>
<li>一定要重视少量内容的重复和模仿</li>
<li>不能仅仅背单词书，要在语料中来理解和记忆单词</li>
<li>一定要每天都学习，坚持至少一年以上</li>
<li>要从最简单的词组和句子入手。入门后，才可以学习语法</li>
</ol>
<h3 id="播讲类材料定义"><a href="#播讲类材料定义" class="headerlink" title="播讲类材料定义"></a>播讲类材料定义</h3><p>学生导向的书，一般就是播讲类材料（带有讲解的材料）。</p>
<h3 id="启蒙老师和播讲类材料的重要性"><a href="#启蒙老师和播讲类材料的重要性" class="headerlink" title="启蒙老师和播讲类材料的重要性"></a>启蒙老师和播讲类材料的重要性</h3><p>仅仅通过所谓浸泡在语言环境里，是不可能让你自动学会语言的。</p>
<p>全英文的播讲类材料是所有英文学习者的必修，而不是选修。</p>
<p>口才好不是抖机灵说段子，而是精通说明性、描述性语言。</p>
<h3 id="适合零基础人群的播讲类材料"><a href="#适合零基础人群的播讲类材料" class="headerlink" title="适合零基础人群的播讲类材料"></a>适合零基础人群的播讲类材料</h3><p>只推荐赖世雄的《赖世雄美语从头学》，不推荐学习高级。</p>
<p>推荐顺序是：先学发音，再学入门，然后是初级，接着是中级，如果学有余力，最后再学习语法。</p>
<p><strong>学习方法</strong>：</p>
<ol>
<li>正襟危坐，集中精力</li>
<li>准备好纸笔，认真听录音同时做笔记</li>
<li>听完一课后，把课文的朗读录音拿出来认真仔细地大声模仿，直到熟练于心</li>
<li>然后进行下一课的学习</li>
<li>平时零碎时间复习笔记上面的知识点</li>
</ol>
<h2 id="初级：英语学习初起步"><a href="#初级：英语学习初起步" class="headerlink" title="初级：英语学习初起步"></a>初级：英语学习初起步</h2><p>初级是整个课程中性价比最高的章节，学完这部分，各方面交谈沟通面试基本没问题，能听懂同事说话，搞定职场绝大部分英文口语问题。</p>
<p>希望达到的目标：</p>
<ul>
<li>基本的日常和商业口语用法词汇量达到大约三千左右</li>
<li>系统的学完发音，并掌握基本的连读知识和自然语言规律</li>
<li>具备基本的开口交流能力</li>
</ul>
<p>大致可以分为三大阶段：</p>
<p><strong>第一阶段</strong>：正音：1 ～ 3 周（推荐教材《赖世雄美语英标》）</p>
<p>第 1 步：</p>
<blockquote>
<p>看书听 CD 不要暂停，跟着录音大声模仿，从头到尾系统地把书学个两到三遍。中间遇到觉得难的章节和句子，记录相关笔记。</p>
<p>建议在一周内完成。</p>
</blockquote>
<p>第 2 步：</p>
<blockquote>
<p>找出重点和难点的章节，重点学习，反复听讲解和模仿。如果有困难，暂时先放着，影响不大。</p>
</blockquote>
<blockquote>
<p>尽量也在一两周内完成。</p>
</blockquote>
<p>建议至少要<strong>在 2 ～ 3 周内把书过几遍</strong>。</p>
<p><strong>注意要点</strong></p>
<ul>
<li>书中所有音标都适用 KK 美式音标标注的</li>
<li>发音不可能通过一本书就学好</li>
<li>学音标一定要用</li>
</ul>
<p><strong>第二阶段</strong>：日常口语和语流训练：1 ～ 2 个月</p>
<p>==推荐教材==：<code>Coach Shane&#39;s Daily Easy English Expression</code></p>
<p>教材共 1000 多个视频，每期视频 3 分钟左右，全部都是老师的讲解。</p>
<p>**==每一期视频建议人真多看几遍，同时跟着大声模仿。最好每天看十个视频以上，不停地跟着模仿==**。一天刚好 1 ～ 2 个小时，在两个月内学完绝大部分视频。</p>
<p><strong>第三阶段</strong>：商业材料听力和、商业领域用法和词汇量积累：1 ～ 2 个月</p>
<p>这个阶段是初级的补充材料，可以和第二阶段同时进行或者选择不学该阶段。</p>
<p>推荐教材：<code>ESLPOD</code></p>
<ul>
<li><code>Interview Questions Answered</code>《面试问题回答》</li>
<li><code>English for Business Meetings</code>《英文会议》</li>
<li><code>Using English at Work</code>《工作常用英文》</li>
</ul>
<p><strong>学习方法</strong></p>
<ol>
<li>从任何一本书开始，细细地从头到尾听若干遍，途中稍微记点笔记</li>
<li>反复听若干遍，如果仍不明白，把文本打开，阅读到当初的重点和难点，补充到笔记上去</li>
<li>以上步骤完成后，把教科书的音频剪切一下，分成慢速课文、慢速讲解、快速三个部分</li>
<li>将慢速课文部分全部听写下来，如果仍有不懂的，对照文本修改，改完再听写，改到自己可以一次性把所有慢速部分都听写出来为止</li>
<li>把文中出现的所有有用用法和单词都记熟练。搞定一本书后，继续下一本</li>
</ol>
<p>如果希望更进一步，可以拿出全部的快速录音进行跟读和模仿。跟读有三种模式：</p>
<ol>
<li>不看文本，播放一句后暂停，然后跟读。如果跟读不了，倒带反复</li>
<li>翻开文本，不暂停。跟着录音反复朗读，一气呵成</li>
<li>丢开文本，不暂停。跟着录音反复浪拂，一气呵成</li>
</ol>
<p>第一种跟读模式最难，但也是最有用的。一定要彻底突破了第一种后，才能进入第二种模式，这样培养的是查漏补缺。最后在进入第三种模式，熟练稳固，让自己可不看文本，流利脱口而出。</p>
<p>注意：<strong>只推荐使用快速部分进行跟读，用慢速的听力来跟读，意义不大</strong>。</p>
<h2 id="初中级：开始适应常速英语"><a href="#初中级：开始适应常速英语" class="headerlink" title="初中级：开始适应常速英语"></a>初中级：开始适应常速英语</h2><h3 id="初中级学习者的定义"><a href="#初中级学习者的定义" class="headerlink" title="初中级学习者的定义"></a>初中级学习者的定义</h3><p>适合以下人群：</p>
<ul>
<li>听慢速英语觉得不耐烦，但是觉得常速英语又太困难的</li>
<li>英语基础较好，也足够认真，但是听力训练很久，也无法突破图片英语听障，无法听懂常速英语</li>
<li>坚持练了很久听力，进步不大，还是一团模糊，根本不知道如何良好训练</li>
<li>有一定的听力基础，也愿意往上努力，但是觉得市面上的材料要么太难要么太枯燥，美剧电影太困难，新闻播报太枯燥，而且没有什么针对性，比较犹豫下一步规划怎么走</li>
</ul>
<h3 id="初中级学习者的目标和效果评估"><a href="#初中级学习者的目标和效果评估" class="headerlink" title="初中级学习者的目标和效果评估"></a>初中级学习者的目标和效果评估</h3><p>这部分食专门为了听力突破而设置的，希望达到的目标是：</p>
<ul>
<li>积累超过六千的词汇量</li>
<li>基本听懂常速英语，达到未来可以直接拿原版的美剧、书籍之类的材料学习</li>
<li>以后不用再学英语，而是用英语</li>
<li>可以应付绝大部分的口语场合，面对一群老外听说英语不犯怵</li>
</ul>
<h3 id="初中级学习者的学习规划和方法"><a href="#初中级学习者的学习规划和方法" class="headerlink" title="初中级学习者的学习规划和方法"></a>初中级学习者的学习规划和方法</h3><p>这个阶段大约需要三四个月的时间。主要学习两份材料，并且是同时学习。</p>
<p>第一份材料是 <code>Daily Dictation</code>。这是一套视频课程，一共有接近 300 期视频节目。</p>
<p>该课程的学习模式是：</p>
<ol>
<li>第一天首先播放一段非常短的常速录音（大约 30 字以内），内容来自美剧或者 CNN、BBC 等新闻，但是语速很快。播放的时候一句话反复播放很多遍，让你听写，如果一遍就能听写出来，说明是高手；如果要听 5 遍以上才能勉强写出来，需要努力。</li>
<li>第二天会公布答案。然后 Coach Shane 会针对这段文字进行细致的讲解，讲解视频大约 15 分钟左右。会讲解文本内容中的单词意思和词组用法，还会对这段自然语流进行彻底全面的剖析和讲解。</li>
</ol>
<p>资源可以在 B 站等地方找到，在两三个月内把 200 多期视频全部学完比较困难，学不完的话至少要学完 150 期。一天至少要学习 4～5 个视频。在学习的时候，如果有生词，要主动记录在笔记本或者手机词典里，平时零碎时间复习。听写本身完全不重要，最有价值的是老师的讲解，一定认真听，并跟着模仿学习。</p>
<p>第二份材料是 <code>EnglishPod</code>。这是一个教英语的广播节目，每一期都有固定的主题，大概有日常生活、情感问题、商务交流等内容。每一个都会标明等级为 <code>elementary</code>（初级）、<code>intermediate</code>（中级）、<code>upper intermediate</code>（中高级）、<code>advanced</code>（高级）。按标记分为 <code>BCDE</code>，其中 <code>E</code> 级别非常难，词汇量大，不建议轻易尝试，最好直接忽略掉。</p>
<p>当时的节目一共 365 期，可以网上搜索下载。每期 mp3 有三个，1 分钟短对话课文录音，10 分钟讲解录音，5 分钟复习录音。</p>
<p>★ 推荐学习方法</p>
<p>初期学习主要以播讲录音为主要学习材料，认真一期期听下去，边听边做笔记。根据自己的学习习惯来规划，每天听若干期，直到把 365 期全部学完。一般来说，一天听 5 期以上，100 天内可以完成一道两遍。听的时候主要跳过 <code>E</code> 级别的，全部认真听完以后开始精细学习。找出原文本，检查文本里有用的词汇和用法，补充到笔记中；挑出一些你特别喜欢的课程，然后找到单独的录音，接着开始跟读，直到熟练。</p>
<blockquote>
<p><strong>在初中级一定要做跟读</strong>。（重点）</p>
</blockquote>
<h2 id="中级：彻底突破常速英语"><a href="#中级：彻底突破常速英语" class="headerlink" title="中级：彻底突破常速英语"></a>中级：彻底突破常速英语</h2><p>中级的重点是：</p>
<ul>
<li>普及搭配的重要用法</li>
<li>演讲学习+大量泛听+复述新概念英语二</li>
<li>积累词汇，图片听障，流利口语</li>
</ul>
<h3 id="中级学习者的定义"><a href="#中级学习者的定义" class="headerlink" title="中级学习者的定义"></a>中级学习者的定义</h3><p>包括以下人群：</p>
<ul>
<li>英语还算不错，但口语听力就是差那么一口气</li>
<li>英文基础还不错，雅思托福成绩尚可，但打算真正提高水平能力的同学</li>
<li>在国外的留学生，总觉得自己的英文差点劲的同学</li>
</ul>
<h3 id="中级学习者的目标和效果评估"><a href="#中级学习者的目标和效果评估" class="headerlink" title="中级学习者的目标和效果评估"></a>中级学习者的目标和效果评估</h3><p>希望达到的目标：</p>
<ul>
<li>词汇量过八千</li>
<li>彻底突破听力和发音障碍</li>
<li>具备较熟练的阅读能力</li>
<li>具备较流畅的口语能力</li>
</ul>
<p>中级的学习阶段，一共有三个。需要选择三种不同的材料，运用三种不同的方法。</p>
<p>如果时间紧张，可以按照 A -&gt; B -&gt; C 的顺序来依次学习。</p>
<p>如果时间充裕，可以三份材料同时学习，每天时间段分成 A、B、C 三块同时进行，每日三次训练。这三者区别主要是侧重点不同。</p>
<ul>
<li>在英语语言的表达中，表意的重要组成部分不是孤立的单词，而是<strong>固定的语块</strong>。</li>
<li>所谓纯正的英语，是指你有能力用各种小词汇组成的固定搭配来灵活表意，并且注意符合语言的场合环境，这才算是真正的英语好。</li>
</ul>
<p>因此，想解决主动词汇和表达法的难题，最重要的是首先需要有<strong>语块</strong>这个概念，然后进行大量阅读。在阅读的过程中，不知不觉就会积累出很多搭配。除了大量泛读以外，还必须先进行一定剂量的精读，来培养自己主动积累语块搭配的意识。<strong>只记忆这个语块的单个意思，而不是去记生词的所有意思。</strong></p>
<h3 id="中级学习的具体流程规划"><a href="#中级学习的具体流程规划" class="headerlink" title="中级学习的具体流程规划"></a>中级学习的具体流程规划</h3><h4 id="A-阶段：毕业典礼演讲精度模仿"><a href="#A-阶段：毕业典礼演讲精度模仿" class="headerlink" title="A 阶段：毕业典礼演讲精度模仿"></a>A 阶段：毕业典礼演讲精度模仿</h4><ul>
<li>侧重点：积累词汇、提高表达法</li>
<li>注意语体的概念（语体指的是<strong>在适当的场合，使用适当的语言</strong>）</li>
</ul>
<p>选择演讲作为精读模仿材料的原因是：广播、新闻、美剧、原版小说、报刊等等作为口语和写作的表达增强练习材料，都不是特别好的语料，因为<strong>语体</strong>不适合。而演讲则是一个非常严谨靠谱的语体，从演讲开始作为主要语料，学习写作和口语用词，对于中级学习者来说，是最好的选择。</p>
<p><strong>国外演讲种类</strong>：</p>
<ul>
<li>学术演讲：大学里的授课，除非是简单的科普或者人文艺术类能听懂，是最难的材料</li>
<li>历史上的经典演讲：比如 <code>I have a dream</code> 之类的，因为年代问题，用词和句式都非常复杂</li>
<li>TED 演讲：学术演讲的简易版，但是难度也是非常大的</li>
<li>政治演讲：竞选演讲、就职典礼演讲，演讲本身难度不高，但是主要都是美国的政策等，比较枯燥，让人不容易坚持</li>
<li>商业演讲和产品发布会：这个类型的演讲基本都很简单，而且很实用，对工作帮助很大</li>
<li>毕业典礼演讲：这种演讲类型被称为 <code>Commencement Speech</code></li>
</ul>
<p>在这些演讲中，难度最低、内容最有趣的就是<strong>毕业典礼演讲</strong>。在毕业典礼演讲中用到的英文用法，是最值得学习的东西。</p>
<ul>
<li>演讲者们的用法和时态，都是最简单的叙述体，对于学习口语的表达、讲故事的手法有着很大的帮助</li>
<li>语速慢，内容简单实用，不会有难词和长难句，学习难度正好</li>
<li>叙述口气的语体，哲理化的小故事，商业概念事件的阐述，对日常口语和商务口语都有极大的帮助</li>
</ul>
<p>毕业典礼演讲视频可以通过搜索 <code>commencement speech</code> 找到。</p>
<p><strong>具体的学习方法</strong></p>
<p>至少要听读完 30-50 篇，每篇都要精读。</p>
<p>精读需要收集视频和文本，打印出来，一篇篇攻克。看一遍视频，有个基本的理解后，再拿出文本仔细阅读，高亮出不会的单词搭配和觉得不错的短语搭配。</p>
<p>例如马云的演讲稿：</p>
<p>从这篇演讲稿中可以发现如下的一些重点：</p>
<h4 id="B-阶段：大量泛听美剧"><a href="#B-阶段：大量泛听美剧" class="headerlink" title="B 阶段：大量泛听美剧"></a>B 阶段：大量泛听美剧</h4><p>看美剧只能看英文字幕，不可以看中文字幕或者中英字幕。</p>
<p>不推荐情景喜剧类的，这一类非常不适合学英语。</p>
<p>值得推荐的美剧是<strong>生活职场类</strong>和<strong>青春类</strong>的美剧，列表如下：</p>
<ul>
<li>Felicity</li>
<li>Charmed 圣女魔咒</li>
<li>绝望的主妇</li>
<li>星际迷航 The Next Generation</li>
<li>超人前传</li>
<li>明星伙伴</li>
<li>发展受阻</li>
</ul>
<p>除了上述列举的，还可以尝试以下几部：</p>
<ul>
<li>吸血鬼猎人巴菲</li>
<li>道森的小溪</li>
<li>罗斯维尔</li>
<li>Angel 黑暗天使</li>
<li>雪山镇</li>
<li>篮球兄弟</li>
<li>邪恶力量</li>
</ul>
<h4 id="C-阶段：口语输出练习"><a href="#C-阶段：口语输出练习" class="headerlink" title="C 阶段：口语输出练习"></a>C 阶段：口语输出练习</h4><p>需要使用复述幽默短文的方法，这也是口语输出练习的最好方法。</p>
<p>训练方法主要是切入视角 POV 复述。POV 指的是不同视角，即 <code>point of view</code>，以不同人的视角来进行复述，复述时需要始终保持第一人称口吻。</p>
<p>用新概念英语 2 第一课举例：</p>
<ol>
<li>首先拿出一个小故事，大声朗读若干遍，弄清各种生词</li>
<li>开始进行切换视角口头复述。只要愿意发挥想象力，每一个故事都可以用两到三种人称视角来复述</li>
<li>在复述的时候用手机把复述的内容录音下来</li>
<li>复述完毕后，对自己的录音进行修改，注意表达和发音错误，然后再重新复述，知道流利为止</li>
<li>多视角练习完毕后，把文章中比较不错的表达方法摘抄下来做笔记，在零碎时间复习</li>
<li>最好有水平差不多的伙伴搭档</li>
</ol>
<p>复述时的注意事项：</p>
<ul>
<li>首先，尽量不要看原文，直接脱稿复述，如果有困难，那么看原文复述也可以，但是始终要录音</li>
<li>其次，在复述发挥想象力固然是好，但是尽量中规中矩，扎扎实实练好自己口语和造句能力才是主要目的</li>
<li>说的时候要严格注意自己的语法和时态，如果不确定复述时候用什么时态好，那么看原文的文章时态用过去时还是现在时，直接采用原文的时态</li>
</ul>
<p>这个阶段的材料只能是那种稍长的短片幽默故事，至少 100 个字以上。</p>
<p>推荐材料有：</p>
<ul>
<li>《新概念英语》 2 和 3</li>
<li>《读幽默故事学英语词汇》全套六册</li>
<li>《世界幽默故事精选》1、2、3：这套书难度相比上面两种难度过高，仅供学有余力的人选择</li>
</ul>
<h4 id="训练规划参考"><a href="#训练规划参考" class="headerlink" title="训练规划参考"></a>训练规划参考</h4><p>首先，确保自己的英文基础达到了这个阶段。</p>
<p>其次，这个练习要大量地做，至少要练几百个故事，每个故事都要练习 3 个视角以上。每天花多少时间取决于自己，但是至少要半个小时。</p>
<p>在训练的同时，最好大量阅读各类通俗小说。</p>
<p><strong>通俗小说推荐</strong></p>
<p>男生可以看 <code>Sidney Sheldon</code>、<code>James Hadley Chase</code>、<code>John Grisham</code> 这些人的作品，故事都很吸引人。</p>
<p>女生则可以看 <code>Nicholas Sparks</code> 和 <code>Janet Evanovich</code> 的爱情小说。</p>
<p>这些作家写作都相对比较口语化，一些常见单词出现频率较高，多阅读对于口语和考试都有很大的帮助。</p>
<h2 id="中高级：英文语法和阅读"><a href="#中高级：英文语法和阅读" class="headerlink" title="中高级：英文语法和阅读"></a>中高级：英文语法和阅读</h2><p>这部分的重点是<strong>语法</strong>、<strong>大量阅读</strong>和<strong>增加词汇量</strong>。</p>
<h3 id="中高级的定位和适合人群"><a href="#中高级的定位和适合人群" class="headerlink" title="中高级的定位和适合人群"></a>中高级的定位和适合人群</h3><p>首先整个学习过程可以分为 A、B、C 三个体系。A 即零基础，B 是初级到中级，C 是中高级和高级。</p>
<p>在这个阶段，最适合的人群是：</p>
<ul>
<li>已经学完 A 和 B 体系的学习人员</li>
<li>没有学完 A 或 B 体系，但是基础在四级及格左右，希望能够突破考试拿到高分的同时提高英文水平的同学</li>
<li>现实中没有条件练习听说，非常希望能够持续学英语的</li>
</ul>
<h3 id="中高级学习者的目标和效果评估"><a href="#中高级学习者的目标和效果评估" class="headerlink" title="中高级学习者的目标和效果评估"></a>中高级学习者的目标和效果评估</h3><p>在这个阶段，希望达到的水平：</p>
<ul>
<li>词汇量达到一万三到一万五</li>
<li>搞定基本语法和句法</li>
<li>具备较熟练的阅读能力，阅读速度加快</li>
<li>各类考试的阅读题和写作题能拿高分</li>
</ul>
<h3 id="具体方法规划"><a href="#具体方法规划" class="headerlink" title="具体方法规划"></a>具体方法规划</h3><p>中高级只有两个阶段：</p>
<ul>
<li>语法（提高语言水平的第一步）</li>
<li>大量阅读和积累词汇</li>
</ul>
<p>这两个阶段可以按先后来，也可以同时开始。</p>
<h4 id="第一阶段"><a href="#第一阶段" class="headerlink" title="第一阶段"></a>第一阶段</h4><p>第一阶段中，一本赖世雄老师经典语法配上 MP3 教程，认真听完讲座病仔细阅读文本。一本是剑桥中级英语语法。<strong>这两个工作一定要按顺序来</strong>。</p>
<h4 id="第二阶段"><a href="#第二阶段" class="headerlink" title="第二阶段"></a>第二阶段</h4><p>第二阶段中，又可以细分为四个小阶段：</p>
<ol>
<li>入门熟悉</li>
<li>自传</li>
<li>传记</li>
<li>社科</li>
</ol>
<p>第 1 阶段，也称为入门适应期。这个阶段不应该培养词汇量和输入量，而应该培养适应和成就感。应该首先挑选一些比较薄、比较简单的书来看，<strong>看完很重要</strong>，忘记了也没关系，主要是为了培养成就感。</p>
<p>推荐书籍：</p>
<ul>
<li>《谁动了我的奶酪》，Who moved my cheese</li>
<li>《礼物》，The present</li>
<li>《一分钟经理人》，The One Minute Manager</li>
<li>《把信送到加西亚》，A Message to Garcia</li>
<li>《富爸爸穷爸爸》，Rich Dad，Poor Dad</li>
</ul>
<p>上面的书吃透，大致上就有了初步的原版书基础。</p>
<p>第 2 阶段，主要是商业巨子的<strong>名人自传</strong>。在开始读原版书的时候，尽可能的做到从书中看到的用法和表达，能立刻在生活中实际运用，这也对我们书籍的选择要求就很高。</p>
<p>在文学类的书籍中，有很多复杂的长难句和绚丽的大词，但是这些无论是说话、写信、邮件，甚至考试写文章做阅读题，都没有直接的帮助。大人物的自传则不一样，在被询问道相关的过去经历和项目经验的时候，可以直接把传记中的表达法拿来用，非常地道。阅读业内大牛的自传，可以积累大量和本行业相关的名词，而且文字相对都比较浅显，行文叙述都比较平易，非常便于理解。</p>
<p><strong>搞定叙述的表达，不论是考试还是日常使用，英文读和写都能解决起码七成以上的问题</strong>。</p>
<p>名人传记的选择，文体娱乐明星传记 &gt; 商业巨子传记 &gt; 各学科牛人传记 &gt; 政治人物传记（此类不推荐）。</p>
<p>推荐书籍：</p>
<ul>
<li>《奉上幸福》，Delivering Happiness</li>
<li>iWoz 自传</li>
<li>杰克韦尔奇自传 Straight from the Gut 和 Winning</li>
<li>费曼先生的两部自传</li>
</ul>
<p>第 3 阶段则是传记，推荐书籍有：</p>
<ul>
<li>史蒂夫乔布斯传</li>
<li>The Second Coming of Steve Jobs</li>
<li>本杰明富兰克林传</li>
</ul>
<p>第 4 阶段则是社科，这一类面比较广，这里只是推荐部分但是不局限于此。</p>
<ul>
<li>阿尔文•托夫勒的 Power Shift、Future Shock、The Third Wave 这三本</li>
<li>Malcolm Gladwell 的书籍</li>
<li>Bill Bryson 的著作</li>
</ul>
<p>以上三位，从文字难度上来说，是由浅入深的。</p>
<h2 id="高级：如何积累两万词汇量"><a href="#高级：如何积累两万词汇量" class="headerlink" title="高级：如何积累两万词汇量"></a>高级：如何积累两万词汇量</h2><h3 id="适用人群"><a href="#适用人群" class="headerlink" title="适用人群"></a>适用人群</h3><ul>
<li>雅思托福四六级高分，但是英语并不能真正做到运用自如</li>
<li>写作邮件和论文都还可以，但是与人沟通，实在不能做到随心所欲，彻底地轻松自如</li>
</ul>
<blockquote>
<p>高级部分的学习时间很长，至少需要 1～2 年时间。而且 99% 以上对于学完中高级部分的人来说，没有必要学习高级课程。</p>
</blockquote>
<h3 id="学习原理和大致案例"><a href="#学习原理和大致案例" class="headerlink" title="学习原理和大致案例"></a>学习原理和大致案例</h3><p>这个课程中的所有阶段，难度是循序渐进的，顺序不可以打乱。</p>
<h4 id="第一阶段：精读美剧波士顿法律"><a href="#第一阶段：精读美剧波士顿法律" class="headerlink" title="第一阶段：精读美剧波士顿法律"></a>第一阶段：精读美剧波士顿法律</h4><p>找到美剧《波士顿法律》剧集，最好是无字幕的，一共有五季。同时需要剧集的剧本。每一集先看若干遍，然后开始读剧本，把剧本里的每个生词或者难以理解的地方都摘抄出来，把它们弄懂。直到把这部剧集全部看完。（建议看十遍以上）。然后把每一集里面的结案陈词部分摘录出来，反复跟着模仿。如果每天 3 小时以上，大约需要半年的时间完成。</p>
<p>其他类似的剧集有《白宫风云》The West Wing 等。</p>
<p>客观全篇精读和讨论分析波士顿法律，不仅可以提高英语，同时也是比较合理的思维训练和口才训练作业。</p>
<h4 id="第二阶段：中国主题的语块学习法"><a href="#第二阶段：中国主题的语块学习法" class="headerlink" title="第二阶段：中国主题的语块学习法"></a>第二阶段：中国主题的语块学习法</h4><p>中国主题的内容和我们是息息相关的，题材也都很熟悉。所以在阅读心理上就比较容易接受，有生词也不会觉得太难，靠猜也能猜到文章大致在讲的内容。</p>
<p>这部分内容主要是外国人写的书和报刊。推荐从书先看起，因为报刊比较零碎，生词出现的重复频率较低，难度较大。</p>
<p>推荐书籍：</p>
<ul>
<li>何伟的三本书《River Town》、《ORACLE BONES》、《COUNTRY DRIVING》</li>
<li>张彤禾《FACTORY GIRLS》</li>
<li>牛津的通识读本《MODERN CHINA》</li>
<li>James McGregor 的《One Billion Customers》</li>
<li>Evan Osnos 的《Age of Ambition: Chasing Fortune, Truth, and Faith in the New China》</li>
</ul>
<p>这些书籍基本都是大师级的笔法和实用的内容加客观的分析，对读懂中国当下也很有帮助。读完这些后，词汇量基本就增加很多了。</p>
<p>报刊推荐：</p>
<ul>
<li>外交政策</li>
<li>美国 CNN （推荐）</li>
<li>BBC（推荐）</li>
<li>金融时报</li>
<li>经济学人（推荐）</li>
<li>南华早报</li>
<li>中国来信</li>
</ul>
<h2 id="英语考试的真相：针对英语考试的准备"><a href="#英语考试的真相：针对英语考试的准备" class="headerlink" title="英语考试的真相：针对英语考试的准备"></a>英语考试的真相：针对英语考试的准备</h2><p>备考人群可以分为四大类。</p>
<p>第一类是<strong>完全零基础，但是短期内又不得不通过考试的人</strong>。零基础指的是从小没有学习过英语，高考英语都不及格的人。这部分人群基数特别大，容易被忽悠。对于这部分人，彻底死心，不要痴心妄想。</p>
<p>第二类是<strong>基础较差，没有信心通过考试的人</strong>。这部分人群时培训市场上基数最大的人群，也是最容易被忽悠的。 对于这部分的人群的建议是，放弃一切培训班，拿出一两年时间，用心打好自己的英语基础。</p>
<p>英语学习分为两个部分，一个是知识积累，一个是能力提高。如果是以考试为直接目标，那么知识积累和能力提高可以齐头并进。</p>
<p>打基础的方法主要分为A、B、C 三个阶段。</p>
<p>A 阶段选用的材料有三份。第一个是《赖世雄美语音标》，花两周的时间认真学完；第二个是 <code>Daily Easy English Expression</code>，每天十期以上并且大声跟读；第三个就是背单词的 APP。</p>
<p>B 阶段主要学习语法，第一步是学习《赖氏经典英语语法》，第二步是学习《剑桥中级英语语法》英文版。</p>
<p>C 阶段需要培养语音的感知能力，选用的材料是 <code>Coach Shane</code> 的 <code>Daily Dictation</code>。同时也要大量阅读真题文章。</p>
<p>第三类是<strong>刚好卡在及格线上，想要提高自己通过几率的人</strong>。这部分人群参加培训班可能有点用，但是高分前提就是自己的英语能力要非常强。</p>
<p>如果不上培训班，也可以采用上面 B、C 阶段的方法来提高自己。</p>
<p>第四类是<strong>可以通过考试但是希望拿高分的人</strong>。不建议这部分人群再去刷题刷高分。</p>
<p>对于考试的突击和提高，首先，所有的考试涉及的能力考查无外乎 7 项，听、说、读、写、词汇、语音和语法。</p>
<p>语音+听力，如果是美国的考试，可以使用 <code>Daily Dictation</code> （针对这个阶段的同学）和美音的听力教材《Step By Step》；如果是英国的考试，选用 <code>BBC Learning English</code> 和 <code>Listen to this</code>，前者中有两个频道比较好，分别是 <code>talk about english</code> 和 <code>6 minute english</code>。</p>
<p>口语+语音，使用 《赖世雄美语音标》和 <code>Daily Dictation</code> 就可以完全搞定。流利性的问题，大量模仿毕业典礼演讲和复述幽默小故事即可，前文也有提到。</p>
<p>阅读+语法，赖世雄语法讲座搭配《剑桥中级英语语法》英文版。</p>
<p>写作+词汇，采用英文报刊的中国报道部分，方法可以参考前文。</p>
<h2 id="针对听说读写语法发音词汇的专项建议"><a href="#针对听说读写语法发音词汇的专项建议" class="headerlink" title="针对听说读写语法发音词汇的专项建议"></a>针对听说读写语法发音词汇的专项建议</h2><h3 id="词汇绝对不能单独拿出来练习"><a href="#词汇绝对不能单独拿出来练习" class="headerlink" title="词汇绝对不能单独拿出来练习"></a>词汇绝对不能单独拿出来练习</h3><p>三大原因：</p>
<ul>
<li>一词多义，没办法记</li>
<li>光记住意思，不会用</li>
<li>死记硬背，效果特别差</li>
</ul>
<p>良好的学习单词的方法是：</p>
<ul>
<li>在语境中学习单词——在听力和阅读材料中，慢慢积累单词</li>
<li>语块学习法</li>
</ul>
<h3 id="强练口语，等于白练"><a href="#强练口语，等于白练" class="headerlink" title="强练口语，等于白练"></a>强练口语，等于白练</h3><p>培训机构的教学模式往往就是看视频、跟着读和外教聊天。这三者都是针对性较差，效果一般的训练方法。</p>
<h3 id="阅读可以单独集中训练"><a href="#阅读可以单独集中训练" class="headerlink" title="阅读可以单独集中训练"></a>阅读可以单独集中训练</h3><p>阅读量大，意味着词汇量足，阅读速度快。对于在国内备考应试的人来说，最好的方法就是广读书。</p>
<p>短线的阅读训练就是读短篇文章。优点就是有针对性，面向考试。缺点是非常枯燥，不容易坚持，并且效果不一定好。</p>
<p>长线的阅读训练的优点是文章相对有意思，容易坚持，不枯燥。确实也是不太容易坚持，要求时间比较长。这种训练适合打算提高英语能力和基础的同时，又想通过考试的同学。</p>
<p>训练流程分为四个阶段。</p>
<p>第一阶段<strong>熟悉感知，享受阅读</strong>。这个阶段，不要讲究方法和能不能看懂，但是要多读章节书（恐怖、悬疑和科普），至少 50 本。</p>
<p>章节书的推荐：</p>
<ul>
<li>神奇树屋 Magic Tree House（科普类）</li>
<li>鸡皮疙瘩 Goose Bumps（恐怖类）</li>
<li>Nate the Great、A to Z Mysteries、Cam Jansen Mysteries、Capital Mysteries（悬疑类）</li>
</ul>
<p>第二阶段<strong>初步入门，泛读为佳</strong>。这个阶段，要读大概十本左右的原版书，推荐遇到生词就大胆猜，猜不出来就查，不用复习。</p>
<p>小说选择：</p>
<ul>
<li>哈利波特系列和暮光之城系列（奇幻类）</li>
<li>Sidney Sheldon 和 James Patterson 的书（直男导向）</li>
<li>Nicholas Sparks 和 John Green 的书（女性导向）</li>
</ul>
<p>第三阶段<strong>认真通读，积累词汇</strong>。推荐商业类图书和商业巨子的传记，前文有提到过。</p>
<p>第四阶段<strong>反复精读，提升表达</strong>。主要就是采用语块学习法，材料是中国主题的书和文章。</p>
<h3 id="语音可以速成，但是要和听力一起训练"><a href="#语音可以速成，但是要和听力一起训练" class="headerlink" title="语音可以速成，但是要和听力一起训练"></a>语音可以速成，但是要和听力一起训练</h3><p>听力材料的训练，推荐的还是之前提到过的 <code>Daily Easy English Expression</code> 和 <code>Daily Dictation</code>。</p>
<p>在完成上述所有的内容后，精读一部美剧，反复观看，选出喜欢的片段模仿。</p>
<h3 id="英语写作的奥秘"><a href="#英语写作的奥秘" class="headerlink" title="英语写作的奥秘"></a>英语写作的奥秘</h3><p>非文学写作，基本都包含立论观点、整体逻辑结构+例证、收尾这几个关键因素。写作中高分的关键一是立论和逻辑结构，二是语言技巧。语言技巧主要分成<strong>句式结构和语言用法</strong>。速成的方法就是<strong>学语法，学造句</strong>。</p>
]]></content>
      <categories>
        <category>英语学习</category>
      </categories>
      <tags>
        <tag>English</tag>
      </tags>
  </entry>
  <entry>
    <title>chroot下玩转群晖虚拟机</title>
    <url>/2021/03/11/chroot%E4%B8%8B%E7%8E%A9%E8%BD%AC%E7%BE%A4%E6%99%96%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
    <content><![CDATA[<h4 id="概要"><a href="#概要" class="headerlink" title="概要"></a>概要</h4><p>​        仅需要实现软路由的朋友请移步<a href="https://koolshare.cn/thread-76860-1-1.html">《群晖官方套件VirtualDSM实现LEDE X64软路由》</a> ，有更简单的方法。下面主要讲的chroot环境下的折腾方法，一般作为学习用就可以了，同志们，折腾的过程是痛并快乐的，昨晚破天荒10点半睡觉，感觉整个人都活过来了。所以身体还是最重要的。<br>​        在实现LEDE软路由过程中会发现网络无法访问问题，后来经过反复折腾，NAS硬重启N次后，发现chroot里设置的网络，一旦网线插拔变动，网络设置又会让群晖主系统更改，甚至导致群晖无法访问，需要长按关机才能恢复（今天得知其实可以通过群晖的pc端软件synology assistant来重制网络，我图样了）。<br>​    <a id="more"></a><br>​        通篇以群晖916+ 8G版为例，应该也适用其他x86平台的。<br>​        首先你的NAS要是x86的cpu平台，否则没有<a href="https://zh.wikipedia.org/zh-hans/%E5%9F%BA%E4%BA%8E%E5%86%85%E6%A0%B8%E7%9A%84%E8%99%9A%E6%8B%9F%E6%9C%BA">KVM</a>支持，性能捉急。</p>
<img src="/2021/03/11/chroot%E4%B8%8B%E7%8E%A9%E8%BD%AC%E7%BE%A4%E6%99%96%E8%99%9A%E6%8B%9F%E6%9C%BA/forum.php" class="" title="img">
<p>先到群晖管理界面，打开SSH。命令行操作请谨慎，请在知道命令含义的前提下执行，谨慎操作。<br>ssh到群晖上，查看内核模块，有两个地方都有，应该是同一个东西。</p>
<blockquote>
<p>ls -l /lib/modules/kvm*<br>或者<br>ls -l /usr/lib/modules/kvm*<br>有的话执行<br>sudo insmod /lib/modules/kvm.ko<br>sudo insmod /lib/modules/kvm-intel.ko</p>
</blockquote>
<p>kvm-intel.ko，和kvm.ko都存在的话，恭喜你，可以入坑折腾了。<br>由于群晖自带的linux系统缺乏相关软件，自己编译安装相当麻烦。不过可以借助套件中心里的debian-chroot来完成。大家可以参考这个图文并茂的文章<a href="http://tieba.baidu.com/p/3257838822%E3%80%82%E6%88%91%E5%AE%9E%E5%9C%A8%E6%B2%A1%E6%9C%89%E8%BF%99%E4%B8%AA%E7%B2%BE%E5%8A%9B%E5%8E%BB%E6%88%AA%E5%9B%BE%E5%86%99%E4%BA%86%EF%BC%8C%E6%8A%B1%E6%AD%89%E3%80%82">http://tieba.baidu.com/p/3257838822。我实在没有这个精力去截图写了，抱歉。</a></p>
<blockquote>
<p>  1.打开套件中心，新增“来源”：<a href="http://packages.synocommunity.com/">http://packages.synocommunity.com/</a><br>  2.到“社群”标签中找到debian-chroot安装</p>
</blockquote>
<p>​    关于chroot，自己科普吧。总之相当于另外开辟了一个类似“容器”的地方，共享主机的内核和硬件资源，但是“系统盘”里的文件都是新的。<br>这个自带的debian-chroot还可以用，我之前试过，后来我用vp$的debian自建了一个chroot，里面软件都是比较新的，用到了qemu的2.7版本。<br>然后就进入了类似vp$一样的debian系统了，自己配置源，执行如下命令安装qemu-kvm:</p>
<blockquote>
<p>sudo apt-get install qemu-kvm libvirt-bin bridge-utils uml-utilities</p>
</blockquote>
<p>到了这里其实已经可以开始通过直接执行命令行的qemu-system-x86_64来安装和开启系统了。我一开始是粗暴的做法：</p>
<blockquote>
<p>DISKIMG=./win7.img<br>SLIC=./Sony[Sony-VAIO-Sony]2.1.BIN<br>WIN7IMG=./cn_windows_7_ultimate_with_sp1_x64_dvd_u_677408.iso<br>VIRTIMG=./virtio-win-0.1.126.iso</p>
<p>qemu-img create -f qcow2 ${DISKIMG} 50G</p>
<p>qemu-system-x86_64 -acpitable file=${SLIC} <br>-daemonize <br>-usbdevice tablet -cpu host -m 2048 –enable-kvm <br>-drive file=${DISKIMG},if=virtio,cache=writeback <br>-cdrom ${WIN7IMG} <br>-drive file=${VIRTIMG},index=3,media=cdrom <br>-rtc base=localtime,clock=host -smp cores=2,threads=1 <br>-net nic,model=virtio,vlan=0,macaddr=52-54-00-12-34-01 <br>-net tap,vlan=0,ifname=tap1,script=no <br>-boot c -soundhw es1370 <br>-vga qxl -device virtio-serial-pci <br>-chardev spicevmc,id=spicechannel0,name=vdagent <br>-vnc :1</p>
</blockquote>
<p>是不是看得头大，不管你怎么想，我就是这么折腾过来的。后面利用libvirt来高效管理各种虚拟机，还是蛮方便的。</p>
<p>本节要做的是有个概念即可，装好debian-chroot即可。我们用最简单的方法来管理。</p>
<h4 id="chroot篇"><a href="#chroot篇" class="headerlink" title="chroot篇"></a>chroot篇</h4><p>这里是记录安装新chroot文件系统的教程。参照这篇<a href="https://wiki.debian.org/chroot">https://wiki.debian.org/chroot</a><br>操作以debian为例。</p>
<ul>
<li><p>参照</p>
<p><a href="https://wiki.debian.org/chroot">https://wiki.debian.org/chroot</a></p>
<p>（只需要执行前面2个命令即可）</p>
<blockquote>
<p>apt-get install binutils debootstrap<br>mkdir -p /srv/chroot/chroottarget<br>debootstrap testing /srv/chroot/chroottarget <a href="http://httpredir.debian.org/debian">http://httpredir.debian.org/debian</a></p>
</blockquote>
</li>
<li><p>然后执行打包:</p>
<blockquote>
<p>tar jpcf chroottarget.tar.bz2 /srv/chroot/chroottarget（主要加-p保留原来权限）</p>
</blockquote>
</li>
<li><p>拷贝到群晖本地，ssh到群晖上面，备份原来的</p>
<blockquote>
<p>mv /volume*/@appstore/debian-chroot/var/chroottarget/  /volume*/@appstore/debian-chroot/var/chroottarget.bak 这里的*代表你安装套件的时候选择的磁盘位置，如volume3，下同。</p>
</blockquote>
<p>然后执行</p>
<blockquote>
<p>tar jxpf chroottarget.tar.bz2 -C /volume*/@appstore/debian-chroot/var/</p>
</blockquote>
</li>
<li><p>然后参照<a href="https://markpith.wordpress.com/2015/10/26/debian-chroot-on-synology-nas/%C3%A8%C2%BF%C2%9B">https://markpith.wordpress.com/2015/10/26/debian-chroot-on-synology-nas/</a>进行优化chroot系统</p>
</li>
</ul>
<blockquote>
<p>sudo /var/packages/debian-chroot/scripts/start-stop-status chroot  进入chroot系统，这里就是一个完整的debian testing文件系统。</p>
</blockquote>
<p>   接下来的操作都在chroot里做，熟悉debian的同学就轻车熟路了。<br>   编辑/etc/apt/sources.list</p>
<blockquote>
<p>###### Debian Main Repos<br>deb <a href="http://ftp.us.debian.org/debian/">http://ftp.us.debian.org/debian/</a> stretch main contrib non-free<br>deb-src <a href="http://ftp.us.debian.org/debian/">http://ftp.us.debian.org/debian/</a> stretch main contrib non-free</p>
<p>###### Debian Update Repos<br>deb <a href="http://security.debian.org/">http://security.debian.org/</a> stretch/updates main contrib non-free<br>deb <a href="http://ftp.us.debian.org/debian/">http://ftp.us.debian.org/debian/</a> stretch-proposed-updates main contrib non-free<br>deb-src <a href="http://security.debian.org/">http://security.debian.org/</a> stretch/updates main contrib non-free<br>deb-src <a href="http://ftp.us.debian.org/debian/">http://ftp.us.debian.org/debian/</a> stretch-proposed-updates main contrib non-free</p>
</blockquote>
<p>  然后执行</p>
<blockquote>
<p>更新源，更新系统默认编码和时区：<br>apt-get update<br>apt-get upgrade</p>
<p>apt-get install locales<br>dpkg-reconfigure locales<br>dpkg-reconfigure tzdata<br>创建一个和群晖自带系统一样的用户名，这样可以共享同一个home目录，先切到群晖系统下（可以多开几个窗口），查看用户uid,gid<br>id -u username （username改成你自己的）<br>id -g username<br>回到chroot，执行<br>adduser username –uid XXXX –gid YYYY –home /home/username （这里的username和XXXX,YYYY自己替换）</p>
<p>好了后<br>apt-get install sudo<br>adduser username sudo<br>为了更方便进入chroot系统，安装ssh<br>apt-get install ssh<br>修改/etc/ssh/sshd_config 文件，可以配置端口，时间关系，这里不多介绍。</p>
</blockquote>
<p>  回到群晖系统，修改套件的启动脚本，加入home挂载，cgroup挂载（libvirt要用到）</p>
<blockquote>
<p>我在/var/packages/debian-chroot/scripts/start-stop-status文件中新增如下</p>
</blockquote>
<blockquote>
<p>start_daemon函数中加挂载，和起ssh服务<br>grep -q “${CHROOTTARGET}/sys/fs/cgroup “ /proc/mounts || mount –rbind /sys/fs/cgroup ${CHROOTTARGET}/sys/fs/cgroup<br>grep -q “${CHROOTTARGET}/home “ <code>realpath /var/services/homes</code> || mount -o bind <code>realpath /var/services/homes</code> ${CHROOTTARGET}/home</p>
<p>chroot ${CHROOTTARGET} /etc/init.d/ssh start</p>
<p>stop_daemon函数中加卸载，停ssh服务<br>chroot ${CHROOTTARGET} /etc/init.d/ssh stop<br>umount ${CHROOTTARGET}/home<br>umount -R ${CHROOTTARGET}/sys/fs/cgroup</p>
</blockquote>
<p>好了，手工了，重启下debian-chroot套件</p>
<blockquote>
<p>/var/packages/debian-chroot/scripts/start-stop-status stop<br>/var/packages/debian-chroot/scripts/start-stop-status start  没有restart，奇怪了</p>
</blockquote>
<p>接下来干正事了：</p>
<blockquote>
<p>安装qemu，kvm</p>
<p>sudo apt-get install qemu-kvm libvirt-daemon-system libvirt-clients libvirt-daemon bridge-utils uml-utilities</p>
</blockquote>
<p>完工，看下一节。</p>
<h4 id="libvirt篇"><a href="#libvirt篇" class="headerlink" title="libvirt篇"></a>libvirt篇</h4><img src="/2021/03/11/chroot%E4%B8%8B%E7%8E%A9%E8%BD%AC%E7%BE%A4%E6%99%96%E8%99%9A%E6%8B%9F%E6%9C%BA/forum-20210311181105592.php" class="" title="img">
<p>首先进入chroot系统，执行</p>
<blockquote>
<p>/etc/init.d/dbus start<br>/etc/init.d/libvirtd start<br>/etc/init.d/virtlogd start</p>
</blockquote>
<p>启动几个必须的服务，你可以加入到脚本。</p>
<blockquote>
<p>brctl addbr br-lan<br>brctl addif br-lan eth0/1</p>
</blockquote>
<p>创建虚拟网桥</p>
<p>接下来可以安装虚拟机喽，以安装debian为例：</p>
<blockquote>
<p>virt-install –virt-type kvm –network bridge=br-lan –cpu host –vcpus 1 –name jessie-amd64 –memory 512 –cdrom ./debian-8.6.0-amd64-netinst.iso –disk size=4 –os-variant generic –graphics vnc,port=5900</p>
</blockquote>
<p>此时可以通过vnc工具，比如vncviewer，tigervnc来连接到安装界面，比如上面的可以通过 群晖IP::5900来访问到。</p>
<p>接下来可以通过virsh来查看虚拟机列表：</p>
<blockquote>
<p>chroot@NAS916P:~$ sudo virsh list –all<br>Id  Name                  State<br>-—————————————————<br>-   centos7                shut off<br>-   debian8                shut off<br>-   lede                  shut off<br>-   lede1.9                shut off<br>-   win7                  shut off</p>
</blockquote>
<p>还可以通过virt-manager可视化工具来安装和配置。</p>
<p>更多详细请参照：<a href="http://www.isjian.com/virtualization/kvm-libvirt-qemu-2/">http://www.isjian.com/virtualization/kvm-libvirt-qemu-2/</a></p>
<h4 id="安装LEDE-X64实现软路由"><a href="#安装LEDE-X64实现软路由" class="headerlink" title="安装LEDE X64实现软路由"></a>安装LEDE X64实现软路由</h4><p><strong>NAS宿主机:</strong><br>    由于我的NAS(916+)带两张网卡，所以用来做软路由比较方便，按本篇做法可以实现软路由功能，pppoe拨号，内网dhcp 192.168.1.0网段。正常工作，但是我有个困扰很久的难题，一直无法解决，就是虚拟机LEDE充当路由之后，我该通过什么方式来访问宿主机呢，之前两张网卡被桥接后好像都消失了，原来的IP都无法访问。然后按朋友的帮助，说给eht0, eth1分别建立alias，然后桥接alias，我发现也没有用。<br>    先说说我的配置吧，千万别开机应用网络配置，导致机器无法访问（群晖916没有视频接口，一旦网络没了就没了），由于在chroot里，也不会怕自启动。新建一个文件/etc/network/interfaces.d/qemu</p>
<blockquote>
<p>auto lo<br>iface lo inet loopback</p>
<p># The primary network interface<br>auto br-lan<br>iface br-lan inet static<br>     address 192.168.1.2<br>     gateway 192.168.1.1<br>     netmask 255.255.255.0<br>     bridge_ports eth1</p>
<p>auto br-wan<br>iface br-wan inet static<br>    address 10.0.0.250<br>     bridge_ports eth0</p>
<p>auto eth0<br>iface eth0 inet manual</p>
<p>auto eth1<br>iface eth1 inet manual</p>
</blockquote>
<p>然后执行</p>
<blockquote>
<p>/etc/init.d/networking restart</p>
</blockquote>
<p>LEDE系统:<br>首先下载本论坛的img文件，具体下载不罗嗦了。<br>然后执行转换：</p>
<blockquote>
<p>qemu-img convert -f raw -O qcow2 lede-V1.9-Update3-x86-64-combined-squashfs.img lede-V1.9-Update3-x86-64-combined-squashfs.qcow2</p>
</blockquote>
<p>然后用virt-manger自己导入也可以，用我这个配置文件也可以：</p>
<blockquote>
<domain type='kvm'>
 <name>lede</name>
 <uuid>dc54a2a7-fe73-4dd6-8dbf-73a21e802bd0</uuid>
 <memory unit='KiB'>2097152</memory>
 <currentMemory unit='KiB'>2097152</currentMemory>
 <vcpu placement='static'>4</vcpu>
 <os>
  <type arch='x86_64' machine='pc-i440fx-2.7'>hvm</type>
  <boot dev='hd'/>
 </os>
 <features>
  <acpi/>
  <apic/>
  <vmport state='off'/>
 </features>
 <cpu mode='custom' match='exact'>
  <model fallback='allow'>Westmere</model>
 </cpu>
 <clock offset='utc'>
  <timer name='rtc' tickpolicy='catchup'/>
  <timer name='pit' tickpolicy='delay'/>
  <timer name='hpet' present='no'/>
 </clock>
 <on_poweroff>destroy</on_poweroff>
 <on_reboot>restart</on_reboot>
 <on_crash>restart</on_crash>
 <pm>
  <suspend-to-mem enabled='no'/>
  <suspend-to-disk enabled='no'/>
 </pm>
 <devices>
  <emulator>/usr/bin/kvm</emulator>
  <disk type='file' device='disk'>
    <driver name='qemu' type='qcow2'/>
    <source file='/volume3/vm/images/lede-V1.9-Update3.qcow2'/>
    <target dev='vda' bus='virtio'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x07' function='0x0'/>
  </disk>
  <controller type='usb' index='0' model='ich9-ehci1'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x7'/>
  </controller>
  <controller type='usb' index='0' model='ich9-uhci1'>
    <master startport='0'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x0' multifunction='on'/>
  </controller>
  <controller type='usb' index='0' model='ich9-uhci2'>
    <master startport='2'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x1'/>
  </controller>
  <controller type='usb' index='0' model='ich9-uhci3'>
    <master startport='4'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x05' function='0x2'/>
  </controller>
  <controller type='pci' index='0' model='pci-root'/>
  <controller type='virtio-serial' index='0'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x06' function='0x0'/>
  </controller>
  <interface type='bridge'>
    <mac address='52:54:00:b4:e1:26'/>
    <source bridge='br-lan'/>
    <model type='virtio'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x03' function='0x0'/>
  </interface>
  <interface type='bridge'>
    <mac address='52:54:00:c1:ae:db'/>
    <source bridge='br-wan'/>
    <model type='virtio'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x09' function='0x0'/>
  </interface>
  <serial type='pty'>
    <target port='0'/>
  </serial>
  <console type='pty'>
    <target type='serial' port='0'/>
  </console>
  <channel type='spicevmc'>
    <target type='virtio' name='com.redhat.spice.0'/>
    <address type='virtio-serial' controller='0' bus='0' port='1'/>
  </channel>
  <input type='tablet' bus='usb'>
    <address type='usb' bus='0' port='1'/>
  </input>
  <input type='mouse' bus='ps2'/>
  <input type='keyboard' bus='ps2'/>
  <graphics type='spice' autoport='yes'>
    <listen type='address'/>
    <image compression='off'/>
  </graphics>
  <sound model='ich6'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x04' function='0x0'/>
  </sound>
  <video>
    <model type='qxl' ram='65536' vram='65536' vgamem='16384' heads='1' primary='yes'/>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x02' function='0x0'/>
  </video>
  <redirdev bus='usb' type='spicevmc'>
    <address type='usb' bus='0' port='2'/>
  </redirdev>
  <redirdev bus='usb' type='spicevmc'>
    <address type='usb' bus='0' port='3'/>
  </redirdev>
  <memballoon model='virtio'>
    <address type='pci' domain='0x0000' bus='0x00' slot='0x08' function='0x0'/>
  </memballoon>
 </devices>
</domain>
</blockquote>
<p>通过sudo virsh list –all就可以看到lede虚拟机在其中了。执行sudo virsh start lede，就起来了。然后通过sudo virsh console lede就进入了lede的终端，进行如下配置：<br>修改 /etc/config/network， 让eth0就是桥接的宿主机的br-lan，来做内网网卡，eth1就是桥接了宿主机的br-wan，来做pppoe拨号。</p>
<blockquote>
<p>config interface ‘loopback’<br>     option ifname ‘lo’<br>     option proto ‘static’<br>     option ipaddr ‘127.0.0.1’<br>     option netmask ‘255.0.0.0’</p>
<p>config interface ‘lan’<br>     option type ‘bridge’<br>     option ifname ‘eth0’<br>     option proto ‘static’<br>     option ipaddr ‘192.168.1.1’<br>     option netmask ‘255.255.255.0’<br>     option ip6assign ‘60’</p>
<p>config interface ‘wan’<br>     option ifname ‘eth1’<br>     option _orig_ifname ‘eth1’<br>     option _orig_bridge ‘false’<br>     option proto ‘pppoe’<br>     option username ‘user’<br>     option password ‘pass’<br>     option ipv6 ‘auto’<br>     option metric ‘40’</p>
</blockquote>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p>虚拟化相关参照资料：<br><a href="http://cromwell-intl.com/linux/virtualization.html">http://cromwell-intl.com/linux/virtualization.html</a><br><a href="https://wiki.debian.org/SystemVirtualization">https://wiki.debian.org/SystemVirtualization</a><br><a href="https://libvirt.org/formatdomain.html#elementsDisks">https://libvirt.org/formatdomain.html#elementsDisks</a></p>
]]></content>
      <categories>
        <category>chroot</category>
      </categories>
      <tags>
        <tag>Synology</tag>
        <tag>chroot</tag>
      </tags>
  </entry>
  <entry>
    <title>Python环境配置</title>
    <url>/2021/03/16/Python%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="python环境配置"><a href="#python环境配置" class="headerlink" title="python环境配置"></a>python环境配置</h3><p>一个系统多个python版本的管理，日常使用如何做到不污染系统python。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L/usr/local/opt/bzip2/lib -L/usr/local/opt/zlib/lib -L/usr/local/opt/sqlite/lib&quot;</span></span><br><span class="line"><span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/opt/bzip2/include -I/usr/local/opt/zlib/include -I/usr/local/opt/sqlite/include&quot;</span></span><br><span class="line"><span class="built_in">export</span> PYTHON_CONFIGURE_OPTS=<span class="string">&quot;--enable-framework&quot;</span>  //需要加入tkinter： --with-tcl-tk</span><br><span class="line">linux用：env PYTHON_CONFIGURE_OPTS=<span class="string">&quot;--enable-shared&quot;</span> pyenv install</span><br><span class="line"></span><br><span class="line">pyenv install 3.8.6</span><br><span class="line">⚠️注意一个问题：/private/tmp的权限问题，可以sudo chown一下。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">https://stackoverflow.com/questions/60469202/unable-to-install-tkinter-with-pyenv-pythons-on-macos</span><br><span class="line">要让python使用更新的tk库（macOS自带了8.5），可以按照如下步骤</span><br><span class="line">1. 安装tck-tk</span><br><span class="line">※ brew install tcl-tk</span><br><span class="line">※ brew info tcl-tk</span><br><span class="line">tcl-tk: stable 8.6.10 (bottled) [keg-only]</span><br><span class="line">...</span><br><span class="line">==&gt; Caveats</span><br><span class="line">tcl-tk is keg-only, <span class="built_in">which</span> means it was not symlinked into /usr/<span class="built_in">local</span>,</span><br><span class="line">because tk installs some X11 headers and macOS provides an (older) Tcl/Tk.</span><br><span class="line"></span><br><span class="line">If you need to have tcl-tk first <span class="keyword">in</span> your PATH run:</span><br><span class="line">  <span class="built_in">echo</span> <span class="string">&#x27;export PATH=&quot;/usr/local/opt/tcl-tk/bin:$PATH&quot;&#x27;</span> &gt;&gt; ~/.zshrc</span><br><span class="line"></span><br><span class="line">For compilers to find tcl-tk you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> LDFLAGS=<span class="string">&quot;-L/usr/local/opt/tcl-tk/lib&quot;</span></span><br><span class="line">  <span class="built_in">export</span> CPPFLAGS=<span class="string">&quot;-I/usr/local/opt/tcl-tk/include&quot;</span></span><br><span class="line"></span><br><span class="line">For pkg-config to find tcl-tk you may need to <span class="built_in">set</span>:</span><br><span class="line">  <span class="built_in">export</span> PKG_CONFIG_PATH=<span class="string">&quot;/usr/local/opt/tcl-tk/lib/pkgconfig&quot;</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">2. 重装python</span><br><span class="line">env \</span><br><span class="line">PATH=<span class="string">&quot;<span class="subst">$(brew --prefix tcl-tk)</span>/bin:<span class="variable">$PATH</span>&quot;</span> \</span><br><span class="line">LDFLAGS=<span class="string">&quot;-L<span class="subst">$(brew --prefix tcl-tk)</span>/lib&quot;</span> \</span><br><span class="line">CPPFLAGS=<span class="string">&quot;-I<span class="subst">$(brew --prefix tcl-tk)</span>/include&quot;</span> \</span><br><span class="line">PKG_CONFIG_PATH=<span class="string">&quot;<span class="subst">$(brew --prefix tcl-tk)</span>/lib/pkgconfig&quot;</span> \</span><br><span class="line">CFLAGS=<span class="string">&quot;-I<span class="subst">$(brew --prefix tcl-tk)</span>/include&quot;</span> \</span><br><span class="line">PYTHON_CONFIGURE_OPTS=<span class="string">&quot;--enable-framework --with-tcltk-includes=&#x27;-I<span class="subst">$(brew --prefix tcl-tk)</span>/include&#x27; --with-tcltk-libs=&#x27;-L<span class="subst">$(brew --prefix tcl-tk)</span>/lib -ltcl8.6 -ltk8.6&#x27;&quot;</span> \</span><br><span class="line">pyenv install 3.8.6</span><br></pre></td></tr></table></figure>



<p>更多配置教程：<br><a href="https://opensource.com/article/19/6/python-virtual-environments-mac">https://opensource.com/article/19/6/python-virtual-environments-mac</a><br><a href="https://opensource.com/article/20/4/pyenv">https://opensource.com/article/20/4/pyenv</a><br><a href="https://opensource.com/article/19/5/python-3-default-mac">https://opensource.com/article/19/5/python-3-default-mac</a></p>
<h4 id="python-virtual"><a href="#python-virtual" class="headerlink" title="python virtual"></a>python virtual</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pyenv global 3.7.3</span><br><span class="line">$ $(pyenv <span class="built_in">which</span> python) -m pip install virtualenvwrapper</span><br><span class="line"></span><br><span class="line">$ mkvirtualenv test1</span><br><span class="line">$ mkvirtualenv test2</span><br><span class="line"></span><br><span class="line">$ mkdir -p ~/src/pyfun &amp;&amp; <span class="built_in">cd</span> ~/src/pyfun</span><br><span class="line">$ mkvirtualenv $(basename $(<span class="built_in">pwd</span>))</span><br><span class="line"><span class="comment"># we will see the environment initialize</span></span><br><span class="line">(pyfun)$ workon</span><br><span class="line">pyfun</span><br><span class="line">test1</span><br><span class="line">test2</span><br><span class="line">(pyfun)$ deactivate</span><br><span class="line">$</span><br><span class="line">$ <span class="built_in">cd</span> ~/src/pyfun</span><br><span class="line">(pyfun)$ workon .</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> ~/src/pyfun</span><br><span class="line">$ rmvirtualenv $(basename $(<span class="built_in">pwd</span>))</span><br><span class="line">$ mkvirtualenv $(basename $(<span class="built_in">pwd</span>))</span><br></pre></td></tr></table></figure>

<h6 id="创建虚拟环境"><a href="#创建虚拟环境" class="headerlink" title="创建虚拟环境"></a>创建虚拟环境</h6><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenv 2.7.15 env-name</span><br></pre></td></tr></table></figure>

<p>若不指定 python 版本，会默认使用当前环境 python 版本。如果指定 Python 版本，则一定要是已经安装过的版本，否则会出错。环境的真实目录位于 <code>~/.pyenv/versions</code> 下</p>
<h5 id="列出当前虚拟环境"><a href="#列出当前虚拟环境" class="headerlink" title="列出当前虚拟环境"></a>列出当前虚拟环境</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv virtualenvs</span><br><span class="line">pyenv activate env-name  # 激活虚拟环境</span><br><span class="line">pyenv deactivate #退出虚拟环境，回到系统环境</span><br></pre></td></tr></table></figure>

<h5 id="删除虚拟环境"><a href="#删除虚拟环境" class="headerlink" title="删除虚拟环境"></a>删除虚拟环境</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pyenv uninstall env-name</span><br><span class="line">rm -rf ~&#x2F;.pyenv&#x2F;versions&#x2F;env-name  # 或者删除其真实目录</span><br></pre></td></tr></table></figure>

<p>使用 pyenv 来管理 python，使用 pyenv-virtualenv 插件来管理多版本 python 包。此时，还需注意，当我们将项目运行的 env 环境部署到生产环境时，由于我们的 python 包是依赖 python 的，需要注意生产环境的 python 版本问题。</p>
<h5 id="所有命令"><a href="#所有命令" class="headerlink" title="所有命令"></a>所有命令</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ pyenv commands</span><br><span class="line">activate</span><br><span class="line">commands</span><br><span class="line">completions</span><br><span class="line">deactivate</span><br><span class="line">doctor</span><br><span class="line"><span class="built_in">exec</span></span><br><span class="line">global</span><br><span class="line"><span class="built_in">help</span></span><br><span class="line">hooks</span><br><span class="line">init</span><br><span class="line">install</span><br><span class="line">installer</span><br><span class="line"><span class="built_in">local</span></span><br><span class="line">offline-installer</span><br><span class="line">prefix</span><br><span class="line"><span class="built_in">rehash</span></span><br><span class="line">root</span><br><span class="line">shell</span><br><span class="line">shims</span><br><span class="line">uninstall</span><br><span class="line">update                 <span class="comment"># 更新 pyenv 及插件</span></span><br><span class="line">version</span><br><span class="line">--version</span><br><span class="line">version-file</span><br><span class="line">version-file-read</span><br><span class="line">version-file-write</span><br><span class="line">version-name</span><br><span class="line">version-origin</span><br><span class="line">versions</span><br><span class="line">virtualenv</span><br><span class="line">virtualenv-delete</span><br><span class="line">virtualenv-init</span><br><span class="line">virtualenv-prefix</span><br><span class="line">virtualenvs</span><br><span class="line"><span class="built_in">whence</span></span><br><span class="line"><span class="built_in">which</span></span><br></pre></td></tr></table></figure>

<p><a href="http://einverne.github.io/post/2017/04/pyenv.html">http://einverne.github.io/post/2017/04/pyenv.html</a></p>
<h3 id="MacVim安装于配置"><a href="#MacVim安装于配置" class="headerlink" title="MacVim安装于配置"></a>MacVim安装于配置</h3><p>Brew cask编译好的macvim依赖于brew的<a href="mailto:&#x70;&#x79;&#116;&#x68;&#x6f;&#110;&#x40;&#x33;&#46;&#x39;">&#x70;&#x79;&#116;&#x68;&#x6f;&#110;&#x40;&#x33;&#46;&#x39;</a>，所以需要修改编译参数：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ brew tap macvim-dev/macvim</span><br><span class="line">$ brew edit macvim-dev/macvim/macvim</span><br></pre></td></tr></table></figure>

<p>需要把配置文件里依赖python3的路径修改为你pyenv的路径：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ENV.append &#x27;vi_cv_path_python3&#x27;, &quot;#&#123;HOMEBREW_PREFIX&#125;/bin/python3&quot;</span></span><br><span class="line"><span class="comment"># ENV.append &#x27;vi_cv_dll_name_python3&#x27;, &quot;#&#123;HOMEBREW_PREFIX&#125;/Frameworks/Python.framework/Versions/3.5/Python&quot;</span></span><br><span class="line"></span><br><span class="line">ENV.append <span class="string">&#x27;vi_cv_path_python3&#x27;</span>, <span class="string">&quot;/users/&lt;user name&gt;/. Pyenv/Versions/3.5.1/Bin/Python3&quot;</span></span><br><span class="line">ENV.append <span class="string">&#x27;vi_cv_dll_name_python3&#x27;</span>, <span class="string">&quot;/users/&lt;user name&gt;/. pyenv/versions/3.5.1/lib/libpython3.5m.dylib&quot;</span></span><br></pre></td></tr></table></figure>

<p>然后安装：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --HEAD --with-properly-linked-python2-python3 macvim-dev/macvim/macvim</span><br></pre></td></tr></table></figure>

<p>⚠️最近big sur编译的时候有bug，导致make失败 <a href="https://github.com/macvim-dev/homebrew-macvim/issues/16">https://github.com/macvim-dev/homebrew-macvim/issues/16</a></p>
<p>可以brew edit的时候修改system ‘make’为system ‘sleep 120’，趁它休息的时候手动去目录make（手动可以成功），然后在brew跳过了make就成功了。               </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">brew install --keep-tmp --HEAD --with-properly-linked-python2-python3 macvim-dev/macvim/macvim -v</span><br><span class="line">--keep-tmp可以保留临时文件到/tmp下</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>vim</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 下清空或删除大文件/大量文件的几种方法</title>
    <url>/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">快速删除大文件</span><br></pre></td></tr></table></figure>

<ol>
<li>通过重定向到 Null 来清空文件内容清空或者让一个文件成为空白的最简单方式，是像下面那样，通过 shell 重定向 null （不存在的事物）到该文件：</li>
</ol>
<p># &gt; access.log</p>
<img src="/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/20180523005212176.png" class="" title="img">

<a id="more"></a>

<p>2.使用 : 符号</p>
<p>使用 : 符号，它是 shell 的一个内置命令，等同于 true 命令，它可被用来作为一个 no-op（即不进行任何操作）。另一种清空文件的方法是将 : 或者 true 内置命令的输出重定向到文件中，具体如下：</p>
<p># : &gt; access.log # true &gt; access.log</p>
<img src="/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/20180523005411881.png" class="" title="img">

<p>3.使用 cat/cp/dd 实用工具及 /dev/null 设备来清空文件</p>
<p>在 Linux 中， null 设备基本上被用来丢弃某个进程不再需要的输出流，或者作为某个输入流的空白文件，这些通常可以利用重定向机制来达到，所以 /dev/null 设备文件是一个特殊的文件，它将清空送到它这里来的所有输入，而它的输出则可被视为一个空文件。另外，你可以通过使用 cat命令 显示 /dev/null 的内容然后重定向输出到某个文件，以此来达到清空该文件的目的。</p>
<p># cat /dev/null &gt; access.log</p>
<p>下面，我们将使用 cp命令 复制 /dev/null 的内容到某个文件来达到清空该文件的目的，具体如下所示：</p>
<p># cp /dev/null access.log</p>
<p>而下面的命令中， if 代表输入文件，of 代表输出文件。</p>
<p># dd if=/dev/null of=access.log</p>
<img src="/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/20180523005528676.png" class="" title="img">

<ol start="4">
<li>使用 echo 命令清空文件</li>
</ol>
<p>在这里，你可以使用 echo命令 将空字符串的内容重定向到文件中，具体如下：</p>
<p># echo “” &gt; access.log 或者 # echo &gt; access.log</p>
<p>注意：你应该记住空字符串并不等同于 null 。字符串表明它是一个具体的事物，只不过它的内容可能是空的，但 null 则意味着某个事物并不存在。基于这个原因，当你将 echo命令 的输出作为输入重定向到文件后，使用cat命令来查看该文件的内容时，你将看到一个空白行（即一个空字符串）。要将 null 做为输出输入到文件中，你应该使用 -n 选项，这个选项将告诉 echo 不再像上面的那个命令那样输出结尾的那个新行。</p>
<p># echo -n “” &gt; access.log</p>
<img src="/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/20180523005623226.png" class="" title="img">

<ol start="5">
<li>使用 truncate 命令来清空文件内容</li>
</ol>
<p>truncate 可被用来将一个文件缩小或者扩展到某个给定的大小。你可以利用它和 -s 参数来特别指定文件的大小。要清空文件的内容，则在下面的命令中将文件的大小设定为 0:</p>
<p># truncate -s 0 access.log</p>
<p>我要介绍的就是这么多了。在本文中，我们介绍了几种通过使用一些简单的命令行工具和 shell 重定向机制来清除或清空文件内容的方法。</p>
<img src="/2021/04/04/Linux-%E4%B8%8B%E6%B8%85%E7%A9%BA%E6%88%96%E5%88%A0%E9%99%A4%E5%A4%A7%E6%96%87%E4%BB%B6-%E5%A4%A7%E9%87%8F%E6%96%87%E4%BB%B6%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/20180523005658496.png" class="" title="img">

<p>6.使用rsync命令</p>
<p>假如你有一些特别大的文件要删除，比如nohup.out这样的实时更新的文件，动辄都是几十个G上百G的，也可以用rsync来清空大文件，而且效率比较高。</p>
<p>1）创建空文件</p>
<p># touch/data/blank.txt</p>
<p>2）用rsync清空文件</p>
<p># rsync -a –delete-before –progress –stats /root/blank.txt /root/nohup.out</p>
<p><strong>快速删除大量文件</strong></p>
<p>假如你要在linux下删除大量文件，比如100万、1000万，像/var/spool/clientmqueue/的mail邮件，/usr/local/nginx/proxy_temp的nginx缓存等，那么rm -rf *可能就不好使了。 rsync 可以用来清空目录或文件，如下：</p>
<p>1）先建立一个空目录# mkdir/data/blank</p>
<p>2）用rsync删除目标目录</p>
<p># rsync –delete-before -d /data/blank/ /var/spool/clientmqueue/</p>
<p>这样目标目录很快就被清空了</p>
<p>注：其中–delete-before 接收者在传输之前进行删除操作</p>
<p><strong><em>\</em>为什么rsync能够快速删除\</strong>*<em>大文件？***</em></p>
<p><em>1<strong>）</strong>rm命令大量调用了lstat64和unlink，可以推测删除每个文件前都从文件系统中做过一次lstat操作。过程：正式删除工作的第一阶段，需要通过getdirentries64调用，分批读取目录（每次大约为4K），在内存中建立rm的文件列表；第二阶段，lstat64确定所有文件的状态；第三阶段，通过unlink执行实际删除。这三个阶段都有比较多的系统调用和文件系统操作。</em></p>
<p><em>2<strong>）</strong>rsync所做的系统调用很少<strong>：</strong>没有针对单个文件做lstat和unlink操作。命令执行前期，rsync开启了一片共享内存，通过mmap方式加载目录信息。只做目录同步，不需要针对单个文件做unlink。</em>另外，在其他人的评测里，rm的上下文切换比较多，会造成System CPU占用较多——对于文件系统的操作，简单增加并发数并不总能提升操作速度。 总结：频繁做减法不如直接从头来过把文件系统的目录与书籍的目录做类比，rm删除内容时，将目录的每一个条目逐个删除(unlink)，需要循环重复操作很多次；rsync删除内容时，建立好新的空目录，替换掉老目录，基本没开销。</p>
<p>参考：<a href="https://blog.csdn.net/liuxiao723846/article/details/51626305">https://blog.csdn.net/liuxiao723846/article/details/51626305</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>86u流畅观看iptv，可接猫，接路由，udpxy</title>
    <url>/2021/09/22/86u%E6%B5%81%E7%95%85%E8%A7%82%E7%9C%8Biptv%EF%BC%8C%E5%8F%AF%E6%8E%A5%E7%8C%AB%EF%BC%8C%E6%8E%A5%E8%B7%AF%E7%94%B1%EF%BC%8Cudpxy/</url>
    <content><![CDATA[<p>​    <strong>最近更新：</strong>    把路由lan口从vlan85里剔除，只通过eth0(wan口）来转发。盒子接光猫，内网都通过udpxy(也是走eth0.85)来看。这样可以让局域网免受iptv组播流影响。精简代码如下：<br>/jffs/scripts/iptv-start   </p>
<a id="more"></a> 

<blockquote>
<p>#—————-For modem connecting———用于局域网访问光猫，可不配，和光猫一个网段<br>ifconfig eth0:1 192.168.1.200 netmask 255.255.255.0</p>
<p>#—————-DHCP for moden——————–#<br>#盒子连光猫，配置一个不和局域网冲突的网段，随意，用来给盒子提供dhcp option<br>ip addr add 192.168.99.1/24 dev eth0<br>iptables -I INPUT -i eth0 -m state –state NEW -j ACCEPT<br>iptables -I FORWARD -i eth0 -o ppp0 -j ACCEPT</p>
<p>vconfig set_name_type DEV_PLUS_VID_NO_PAD<br>vconfig add eth0 85</p>
<p>brctl addbr vlan85<br>brctl addif vlan85 eth0.85</p>
<p>#vlan85可以静态配置，可以dhcp获取，二选一,自己打开注释<br>#####Static############<br>ifconfig vlan85 192.168.55.2 up</p>
<p>###########dhcp#########<br>#ps w|grep udhcpc|grep vlan85|awk ‘{print “kill -9 “$1}’|sh<br>#/sbin/udhcpc -i vlan85 -p /var/run/udhcpc10.pid -s /jffs/udhcpc.sh</p>
<p>#————–Open Udpxy——————–#<br>iptables -I INPUT -d 224.0.0.0/4 -p udp -m udp ! –dport 1900 -j ACCEPT<br>iptables -I INPUT -d 224.0.0.0/4 -p igmp -j ACCEPT<br>sleep 16<br>killall udpxy<br>#/jffs/scripts/udpxy -B 2097152 -m vlan85 -p 4022 -c 5<br>/usr/sbin/udpxy -m vlan85 -p 4022 -c 10</p>
</blockquote>
<pre><code> /jffs/udhcpc.sh</code></pre>
<blockquote>
<p>#!/bin/sh<br># udhcpc script edited by Tim Riker <a href="mailto:&#84;&#105;&#109;&#x40;&#x52;&#105;&#x6b;&#x65;&#114;&#x73;&#x2e;&#111;&#114;&#103;">&#84;&#105;&#109;&#x40;&#x52;&#105;&#x6b;&#x65;&#114;&#x73;&#x2e;&#111;&#114;&#103;</a><br>[ -z “$1” ] &amp;&amp; echo “Error: should be called from udhcpc” &amp;&amp; exit 1<br>RESOLV_CONF=”/etc/resolv.conf”<br>[ -n “$broadcast” ] &amp;&amp; BROADCAST=”broadcast $broadcast”<br>[ -n “$subnet” ] &amp;&amp; NETMASK=”netmask $subnet”</p>
<p>case “$1” in<br>     deconfig)<br>          /sbin/ifconfig $interface 0.0.0.0<br>          ;;<br>     renew|bound)<br>          /sbin/ifconfig $interface $ip $BROADCAST $NETMASK<br>          ;;<br>esac<br>exit 0</p>
</blockquote>
<p>​    /jffs/configs/dnsmasq.d/iptv.conf</p>
<blockquote>
<p>#open dhcp server on eth0<br>interface=eth0<br>dhcp-range=interface:eth0,192.168.99.2,192.168.99.10,255.255.255.0,86400s<br>dhcp-option=interface:eth0,3,192.168.99.1<br>dhcp-option=interface:eth0,252,”\n”<br>dhcp-option=interface:eth0,15<br>dhcp-option=interface:eth0,28<br>dhcp-option=interface:eth0,60,00:00:01:00:02:03:43:50:45:03:0e:45:38:20:47:50:4f:4e:20:52:4f:55:54:45:52:04:03:31:2E:30<br>dhcp-option-force=interface:eth0,125,00:00:00:00:1a:02:06:48:47:57:2d:43:54:0a:02:20:00:0b:02:00:55:0d:02:00:2e</p>
</blockquote>
<p>————————-以下是原文章，想内网接iptv盒子的看——————————————————————–</p>
<p>​    这篇文章本来不想发的，因为论坛里已经有很多大神发了不少教程。最近发现有很多朋友遇到iptv播放报156，0018错误，我自己也掉坑，折腾了好久，一一调试出来，所以发个帖比较醒目一点。一来把过程记录下来，做个备份，二来给遇到同样问题的朋友一点帮助。自己也不是专业做网络的，写出来让各位大神也帮我挑挑毛病，分析下真正问题，以下折腾离不开各路大神的原创思路。</p>
<p>​    具体操作大同小异，我分析了造成播放卡顿的主要原因是把br0（也就是包含了eth5, eth6俩无线接口）全部加入vlan85，然后这个组播流和wifi接口有冲突，或者和家里wifi设备也有一定关系，这个需要大神们来帮忙解开这个谜底了。</p>
<p>​    本操作拓扑就是 猫桥接模式，1，3，4口选一个接路由wan口。iptv盒子可以接猫剩下的口，也可以接路由的lan口。手抖图就不画了。<br>​    猫的设置参照<a href="https://koolshare.cn/thread-170588-1-1.html">上海4K IPTV桥接模式脚本 适用于AC86U AX88U等新路由</a>。<br>​    路由设置：<br>​    新增/jffs/scripts/iptv-start，同时在/jffs/scripts/nat-start里新增一行执行此脚本的行：sh /jffs/scripts/iptv-start（iptv-start名字可以随便取，它本身不会自动执行）</p>
<blockquote>
<p>##路由接通光猫-感谢diskerjtr-提供代码-<br>#—————-For modem connecting——————-#<br>ifconfig eth0:1 192.168.1.200 netmask 255.255.255.0<br>iptables -t nat -I POSTROUTING -o eth0 -d 192.168.1.0/24 -j MASQUERADE</p>
<p>#—————-DHCP for modem感谢diskerjtr-提供代码——————–#<br>ip addr add 192.168.99.1/24 dev eth0<br>iptables -I INPUT -i eth0 -m state –state NEW -j ACCEPT<br>iptables -I FORWARD -i eth0 -o ppp0 -j ACCEPT</p>
<p>#————-Vlan For LAN TV—-以下撇开eth5, eth6两个wifi接口———–#<br>vconfig set_name_type DEV_PLUS_VID_NO_PAD<br>vconfig add eth0 85<br>ip link add link eth1 name eth1.85 type vlan id 85<br>ip link add link eth2 name eth2.85 type vlan id 85<br>ip link add link eth3 name eth3.85 type vlan id 85</p>
<p>#以上必须用ip命令创建vlan，vconfig建的eth[123].85不知为何无法加入网桥<br>brctl addbr vlan85<br>brctl addif vlan85 eth0.85<br>brctl addif vlan85 eth1.85<br>brctl addif vlan85 eth2.85<br>brctl addif vlan85 eth3.85</p>
<p>#set vlan85 igmp snooping mode to 1<br>bcmmcastctl mode -i vlan85 -p 1 -m 1</p>
<p>ifconfig eth0.85 up<br>ifconfig eth1.85 up<br>ifconfig eth2.85 up<br>ifconfig eth3.85 up<br>ifconfig vlan85 192.168.98.1 netmask 255.255.255.0 up</p>
<p>#————–Open Udpxy——————–#<br>iptables -I INPUT -d 224.0.0.0/4 -p udp -m udp ! –dport 1900 -j ACCEPT<br>iptables -I INPUT -d 224.0.0.0/4 -p igmp -j ACCEPT<br>sleep 16<br>killall udpxy<br>/usr/sbin/udpxy -m vlan85 -p 4022 -c 20</p>
</blockquote>
<pre><code>/jffs/configs/dnsmasq.d/iptv.conf</code></pre>
<blockquote>
<p>#open dhcp server on eth0<br>interface=eth0<br>dhcp-range=interface:eth0,192.168.99.2,192.168.99.10,255.255.255.0,86400s<br>dhcp-option=interface:eth0,3,192.168.99.1<br>dhcp-option=interface:eth0,252,”\n”<br>dhcp-option=interface:eth0,15<br>dhcp-option=interface:eth0,28<br>dhcp-option=interface:eth0,60,00:00:01:00:02:03:43:50:45:03:0e:45:38:20:47:50:4f:4e:20:52:4f:55:54:45:52:04:03:31:2E:30<br>dhcp-option-force=interface:eth0,125,00:00:00:00:1a:02:06:48:47:57:2d:43:54:0a:02:20:00:0b:02:00:55:0d:02:00:2e</p>
<p>#dhcp server for br0<br>dhcp-option-force=125,00:00:00:00:1a:02:06:48:47:57:2d:43:54:03:04:5a:58:48:4e:0a:02:20:00:0b:02:00:55:0d:02:00:2e<br>dhcp-option=15<br>dhcp-option=28<br>dhcp-option=60,00:00:01:06:68:75:61:71:69:6E:02:0A:48:47:55:34:32:31:4E:20:76:33:03:0A:48:47:55:34:32:31:4E:20:76:33:04:10:32:30:30:2E:55:59:59:2E:30:2E:41:2E:30:2E:53:48:05:04:00:01:00:50</p>
</blockquote>
<p>感谢几位大神的原创:<a href="https://koolshare.cn/thread-169323-1-2.html">路由器 VLAN 配置 - vconfig 用法示例</a><br><a href="https://koolshare.cn/thread-133246-1-1.html">丢了你的iptv吧！上海电信IPTV直播源 、组播源</a><br><a href="https://koolshare.cn/thread-43568-1-1.html">上海电信完美解决4K IPTV一劳永逸增强板</a><br><a href="https://koolshare.cn/thread-170588-1-1.html">上海4K IPTV桥接模式脚本 适用于AC86U AX88U等新路由</a><br>特别是<a href="https://koolshare.cn/space-uid-10449.html">diskerjtr</a>大佬给予了很多远程支持。很多东西都是他推荐的，比如udpxy，tvheadend，live channel播放器。</p>
]]></content>
      <categories>
        <category>iptv</category>
      </categories>
  </entry>
  <entry>
    <title>Android脱壳</title>
    <url>/2021/03/16/Android%E8%84%B1%E5%A3%B3/</url>
    <content><![CDATA[<h3 id="安装服务端（android）"><a href="#安装服务端（android）" class="headerlink" title="安装服务端（android）"></a>安装服务端（android）</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">安卓端：</span><br><span class="line">https://github.com/frida/frida/releases</span><br><span class="line">下载frida-server-x.y.z-android-x86.xz</span><br><span class="line"><span class="comment"># adb devices</span></span><br><span class="line"><span class="comment"># adb -s emulator-5554 push frida-server-14.2.18-android-x86 /data/</span></span><br><span class="line"><span class="comment"># adb kill-server &amp;&amp; adb server &amp;&amp; adb shell 进入android的shell运行frida-server</span></span><br><span class="line"></span><br><span class="line">主机端：</span><br><span class="line">https://github.com/hluwa/FRIDA-DEXDump</span><br><span class="line">安装pip3 install frida-dexdump</span><br><span class="line">到安卓运行app，然后执行如下命令导出dex</span><br><span class="line"><span class="comment"># frida-dexdump</span></span><br><span class="line"></span><br><span class="line">frida-dexdump报错的话，用如下命令：</span><br><span class="line"><span class="comment"># frida -U -f &#123;包名&#125; -l dexDump.js --no-pause</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>frida</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title>Find 过滤搜索、目录层级限制(-maxdepth、-mindepth)以及常用搜索技巧小结</title>
    <url>/2021/05/23/Find-%E8%BF%87%E6%BB%A4%E6%90%9C%E7%B4%A2%E3%80%81%E7%9B%AE%E5%BD%95%E5%B1%82%E7%BA%A7%E9%99%90%E5%88%B6-maxdepth%E3%80%81-mindepth-%E4%BB%A5%E5%8F%8A%E5%B8%B8%E7%94%A8%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p><strong>find过滤目录</strong></p>
<p>使用find命令在linux系统中查找文件时，有时需要忽略某些目录，可以使用”-path 过滤的目录路径 -prune -o”参数来进行过滤。不过必须注意：要忽略的路径参数要紧跟着搜索的路径之后，否则该参数无法起作用。</p>
<a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">首先拿一个例子来说明下：</span><br><span class="line">比如查找/data/web/ssy/online路径下的的目录，并统计目录大小，以G位单位进行排序（默认为降序），并统计前10个大小的目录。命令如下：</span><br><span class="line"><span class="comment"># find /data/web/ssy/online/* -maxdepth 0 -type d -exec /usr/bin/du -sh &#123;&#125; \;|grep &#x27;[0-9]G&#x27;|sort -rh|head -10</span></span><br><span class="line"> </span><br><span class="line">查找/data/web/ssy/online路径下除tmp目录之外的目录，并统计目录大小，以G位单位进行排序（默认为降序），并统计前10个大小的目录。命令如下</span><br><span class="line"><span class="comment"># find /data/web/ssy/online/* -path /data/web/ssy/online/tmp -prune -o -maxdepth 0 -type d -exec /usr/bin/du -sh &#123;&#125; \;|grep &#x27;[0-9]G&#x27;|sort -rh|head -10</span></span><br><span class="line"> </span><br><span class="line">注意：</span><br><span class="line">1）<span class="string">&quot;-maxdepth 0&quot;</span> 表示只查找到/data/web/ssy/online下的目录。如果是<span class="string">&quot;-maxdepth 1&quot;</span>则表示查找到/data/web/ssy/online/xxx下的目录</span><br><span class="line">2）find命令中的过滤、忽略、排除使用<span class="string">&quot;-path 过滤的文件或目录-prune -o &quot;</span>，其中-prune类似于<span class="keyword">if</span>判断，如果-prune之前的语句为真，比如找到了</span><br><span class="line">   前面-path指定的/data/web/ssy/online/tmp目录，就不再执行后面-o跟的语句了，如果没有找到则执行后面的语句。这样就做到了排除效果！</span><br><span class="line">   其中的<span class="string">&quot;-o&quot;</span> 是 <span class="string">&quot;-or&quot;</span> 的意思！</span><br><span class="line">3）-path要过滤掉的文件或目录路径参数一定要紧跟在要搜索的路径之后，否则过滤效果就不会实现！！也就是说上面的<span class="string">&quot;-path /data/web/ssy/online/tmp&quot;</span></span><br><span class="line">   必须紧跟着放在<span class="string">&quot;/data/web/ssy/online/*&quot;</span>后面，否则查找时就不会过来掉/data/web/ssy/online/tmp这个目录。</span><br><span class="line"> </span><br><span class="line">========================================================================================================================================================</span><br><span class="line">示例一：</span><br><span class="line">假设/opt/kevin目录下有三个目录：test1，test2，test3，三个目录下都有list文件</span><br><span class="line">[root@localhost kevin]<span class="comment"># pwd</span></span><br><span class="line">/opt/kevin</span><br><span class="line">[root@localhost kevin]<span class="comment"># ls</span></span><br><span class="line">test1  test2  test3</span><br><span class="line"> </span><br><span class="line">现在要查找/opt/kevin路径下的list文件，并忽略掉test2目录，操作如下：</span><br><span class="line">[root@localhost kevin]<span class="comment"># pwd</span></span><br><span class="line">/opt/kevin</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -type f -name list</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -type f -name list -print</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line">使用-path 和 -prune -o实现过滤效果</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -path test2 -prune -o -type f -name list -print  </span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -path ./test2/ -prune -o -type f -name list -print</span></span><br><span class="line">find: warning: -path ./test2/ will not match anything because it ends with /.</span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line">当搜索路径不是全路径时，过滤目录路径必须是./test2 才能实现过滤效果！</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -path ./test2 -prune -o -type f -name list -print</span></span><br><span class="line">./test1/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">要过滤的目录操作-path必须紧跟着搜索路径 才能实现过滤效果</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -type f -path ./test2 -prune -o -name list -print</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line">当搜索路径时全路径时，过滤路径也要是全路径，才能实现过滤效果</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -path /opt/kevin/test2 -prune -o -type f -name list -print  </span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/ -path /opt/kevin/test2 -prune -o -type f -name list -print</span></span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line">/opt/kevin/test3/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/* -path /opt/kevin/test2 -prune -o -type f -name list -print</span></span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line">/opt/kevin/test3/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin -path /opt/kevin/test2 -prune -o -type f -name list -print </span></span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line">/opt/kevin/test3/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin -path /opt/kevin/test2/ -prune -o -type f -name list -print</span></span><br><span class="line">find: warning: -path /opt/kevin/test2/ will not match anything because it ends with /.</span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line">/opt/kevin/test2/list</span><br><span class="line">/opt/kevin/test3/list</span><br><span class="line"> </span><br><span class="line">由上面可知：</span><br><span class="line">1）当要搜索的目录不是全路径时，要过滤掉的目录必须是<span class="string">&quot;./test2&quot;</span>才能实现过滤效果。如果是<span class="string">&quot;test2&quot;</span>或者<span class="string">&quot;./test2/&quot;</span>都不能实现过滤效果。</span><br><span class="line">2）当要搜索的目录是全路径时，要过滤掉的目录也必须是全路径才能实现过滤效果！要过滤掉的目录后面不能加<span class="string">&quot;/&quot;</span>，否则也不能实现过滤效果。</span><br><span class="line">3）过滤操作<span class="string">&quot;-path /opt/kevin/test2/ -prune -o&quot;</span>必须紧跟在要搜索路径的后面才能实现过滤效果，否则也不能实现过滤效果。</span><br><span class="line"> </span><br><span class="line">如果要过滤两个目录，比如过滤掉test2和test3目录，则使用转义符\( -path ./test2 -o -path ./test3 -prune -o \)</span><br><span class="line">注意：两个转义符前面都要有空格！！</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -path ./test2 -o -path ./test3 -prune -o -type f -name list -print</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . \( -path ./test2 -o -path ./test3 \) -prune -o -type f -name list -print</span></span><br><span class="line">./test1/list</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/ \( -path /opt/kevin/test2 -o -path /opt/kevin/test3 \) -prune -o -type f -name list -print  </span></span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line"> </span><br><span class="line">除了上面的方法，还有一个方法如下：</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -type f -name list ! -path ./test2/* ! -path ./test3/*     </span></span><br><span class="line">./test1/list</span><br></pre></td></tr></table></figure>

<p><strong>find过滤文件</strong><br>先查看对应文件，然后使用”grep -v”进行过滤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">比如只查找/opt/kevin目录下的文件（不查找/opt/kevin的二级目录下的文件），并过滤到haha2文件</span><br><span class="line">[root@localhost kevin]<span class="comment"># pwd</span></span><br><span class="line">/opt/kevin</span><br><span class="line">[root@localhost kevin]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha1</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha2</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha3</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha4</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test1</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test2</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test3</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f |grep -v &quot;haha2&quot;</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">过滤多个文件，就使用多个<span class="string">&quot;grep -v&quot;</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f |grep -v &quot;haha2&quot;</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f |grep -v &quot;haha2&quot;|grep -v haha3</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f |grep -v &quot;haha2&quot;|grep -v haha3|grep -v haha4</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br></pre></td></tr></table></figure>

<p><strong><em>find命令中的-maxdepth和-mindepth：控制搜索深度的选项</em></strong><br>-maxdepth ：指定遍历搜索的最大深度。最大目录层级<br>-mindepth： 指定开始遍历搜索的最小深度。最小目录层级</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">-maxdepth 0：最大目录层级为0，表示只针对当前目录本身(比如/opt/kevin)进行搜索操作或du -sh 统计操作。</span><br><span class="line">-maxdepth 1：最大目录层级为1，表示针对/opt/kevin/ 路径进行搜索操作或du -sh 统计操作。</span><br><span class="line">-maxdepth 2：最大目录层级为2，表示针对/opt/kevin/xxx/ 路径进行搜索操作或du -sh 统计操作。</span><br><span class="line">   </span><br><span class="line">[root@localhost kevin]<span class="comment"># pwd</span></span><br><span class="line">/opt/kevin</span><br><span class="line">[root@localhost kevin]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha1</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha2</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha3</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha4</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test1</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test2</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test3</span><br><span class="line">   </span><br><span class="line">-maxdepth 0 表示最小目录层级是0，即搜索路径它本身</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 0 -type f</span></span><br><span class="line">  </span><br><span class="line">但是如果当前路径加入<span class="string">&quot;*&quot;</span>使用<span class="string">&quot;-maxdepth 0&quot;</span> 效果和 当前路径不加<span class="string">&quot;*&quot;</span>使用<span class="string">&quot;-maxdepth 1&quot;</span> 是一样的！</span><br><span class="line">[root@localhost kevin]<span class="comment"># find ./* -maxdepth 0 -type f</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin -maxdepth 0 -type f </span></span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/ -maxdepth 0 -type f</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/* -maxdepth 0 -type f</span></span><br><span class="line">/opt/kevin/haha</span><br><span class="line">/opt/kevin/haha1</span><br><span class="line">/opt/kevin/haha2</span><br><span class="line">/opt/kevin/haha3</span><br><span class="line">  </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin -maxdepth 1 -type f</span></span><br><span class="line">/opt/kevin/haha</span><br><span class="line">/opt/kevin/haha1</span><br><span class="line">/opt/kevin/haha2</span><br><span class="line">/opt/kevin/haha3</span><br><span class="line">/opt/kevin/haha4</span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/ -maxdepth 1 -type f</span></span><br><span class="line">/opt/kevin/haha</span><br><span class="line">/opt/kevin/haha1</span><br><span class="line">/opt/kevin/haha2</span><br><span class="line">/opt/kevin/haha3</span><br><span class="line">/opt/kevin/haha4</span><br><span class="line">  </span><br><span class="line">[root@localhost kevin]<span class="comment"># find /opt/kevin/* -maxdepth 1 -type f</span></span><br><span class="line">/opt/kevin/haha</span><br><span class="line">/opt/kevin/haha1</span><br><span class="line">/opt/kevin/haha2</span><br><span class="line">/opt/kevin/haha3</span><br><span class="line">/opt/kevin/haha4</span><br><span class="line">/opt/kevin/test1/list</span><br><span class="line">/opt/kevin/test2/list</span><br><span class="line">/opt/kevin/test3/list</span><br><span class="line">  </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 2 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">  </span><br><span class="line">结论：</span><br><span class="line">如果搜索路径后面加了<span class="string">&quot;*&quot;</span>，则使用<span class="string">&quot;-maxdepth n&quot;</span></span><br><span class="line">和</span><br><span class="line">不加<span class="string">&quot;*&quot;</span>使用<span class="string">&quot;-maxdepth n+1&quot;</span></span><br><span class="line">的效果是一样的！！</span><br><span class="line">   </span><br><span class="line">超过了实际目录级层，效果是一样的</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 3 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 4 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">如果仅仅只是在/opt/kevin/xxx下搜索，即这里的最小目录深度是2</span><br><span class="line">[root@localhost kevin]<span class="comment"># pwd</span></span><br><span class="line">/opt/kevin</span><br><span class="line">[root@localhost kevin]<span class="comment"># ll</span></span><br><span class="line">total 0</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha1</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha2</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha3</span><br><span class="line">-rw-r--r-- 1 root root  0 Nov 21 18:51 haha4</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test1</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test2</span><br><span class="line">drwxr-xr-x 2 root root 18 Nov 21 18:24 test3</span><br><span class="line">   </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 2 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">   </span><br><span class="line">最小目录层级为0</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 0 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">最小目录层级为1</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 1 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">   </span><br><span class="line">最小目录层级为3，即超过当前最大目录层级，则就搜索不到了！</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 3 -type f</span></span><br><span class="line"> </span><br><span class="line">========================================================================</span><br><span class="line">-mindepth和-maxdepth可以一起结合起来使用，用于搜索指定层级范围内的文件。</span><br><span class="line">========================================================================</span><br><span class="line">如果只想搜索/opt/kevin/xxx下的文件，可行的做法：</span><br><span class="line">第一种做法：最大目录层级是1，即-maxdepth 1</span><br><span class="line">[root@localhost kevin]<span class="comment"># find ./* -maxdepth 0 -type f</span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 1 -type f            </span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">第二种做法：最小目录层级是1，最大目录层级是1，即-mindepth 1 -maxdepth 1</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 1 -maxdepth 1 -type f </span></span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line"> </span><br><span class="line">再来看下面的示例</span><br><span class="line">[root@localhost kevin]<span class="comment"># echo &quot;123456&quot; &gt; bo/bobo/list1</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># echo &quot;123456&quot; &gt; bo/bobo/list2</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># echo &quot;123456&quot; &gt; bo/bobo/ke/list3</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># echo &quot;123456&quot; &gt; bo/bobo/ke/list4</span></span><br><span class="line">[root@localhost kevin]<span class="comment"># ll bo/</span></span><br><span class="line">total 0</span><br><span class="line">drwxr-xr-x 3 root root 42 Nov 21 23:23 bobo</span><br><span class="line">[root@localhost kevin]<span class="comment"># ll bo/bobo/</span></span><br><span class="line">total 8</span><br><span class="line">drwxr-xr-x 2 root root 32 Nov 21 23:23 ke</span><br><span class="line">-rw-r--r-- 1 root root  7 Nov 21 23:23 list1</span><br><span class="line">-rw-r--r-- 1 root root  7 Nov 21 23:23 list2</span><br><span class="line">[root@localhost kevin]<span class="comment"># ll bo/bobo/ke/</span></span><br><span class="line">total 8</span><br><span class="line">-rw-r--r-- 1 root root 7 Nov 21 23:23 list3</span><br><span class="line">-rw-r--r-- 1 root root 7 Nov 21 23:23 list4</span><br><span class="line"> </span><br><span class="line">如果想搜索/opt/kevin/xxx/xxx下的文件，即最小目录层级是3,最大目录层级是3</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 3 -type f           </span></span><br><span class="line">./bo/bobo/ke/list3</span><br><span class="line">./bo/bobo/ke/list4</span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 3 -type f           </span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 3 -maxdepth 3 -type f</span></span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br><span class="line"> </span><br><span class="line">如果想要搜索第二层级和第三层级之间的文件，如下：</span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 2 -type f           </span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./bo/bobo/ke/list3</span><br><span class="line">./bo/bobo/ke/list4</span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -maxdepth 3 -type f             </span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./haha</span><br><span class="line">./haha1</span><br><span class="line">./haha2</span><br><span class="line">./haha3</span><br><span class="line">./haha4</span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br><span class="line"> </span><br><span class="line">[root@localhost kevin]<span class="comment"># find . -mindepth 2 -maxdepth 3 -type f</span></span><br><span class="line">./test1/list</span><br><span class="line">./test2/list</span><br><span class="line">./test3/list</span><br><span class="line">./bo/bobo/list1</span><br><span class="line">./bo/bobo/list2</span><br></pre></td></tr></table></figure>

<p><strong>############ 更多小示例说明 ############</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">1. 在当前目录下查找所有txt后缀文件</span><br><span class="line"><span class="comment"># find ./ -name &quot;*.txt&quot;</span></span><br><span class="line"> </span><br><span class="line">2.在当前目录下的dir0目录及子目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ -path &quot;./dir0*&quot; -name &quot;*.txt&quot;</span></span><br><span class="line"> </span><br><span class="line">3.在当前目录下的dir0目录下的子目录dir00及其子目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ -path &quot;*dir00*&quot; -name &quot;*.txt&quot;</span></span><br><span class="line"> </span><br><span class="line">4.在除dir0及子目录以外的目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ -path &quot;./dir0*&quot; -a -prune -o -name &quot;*.txt&quot; -print</span></span><br><span class="line">这里注意：</span><br><span class="line">-a 是and的缩写, 意思是逻辑运算符<span class="string">&#x27;与&#x27;</span>(&amp;&amp;);</span><br><span class="line">-o 是or的缩写, 意思是逻辑运算符<span class="string">&#x27;或&#x27;</span>(||), - not 表示非.</span><br><span class="line">上条命令的意思是：</span><br><span class="line">如果目录dir0存在（即-a左边为真），则求-prune的值，-prune 返回真，<span class="string">&#x27;与&#x27;</span>逻辑表达式为真（即-path <span class="string">&#x27;./dir0*&#x27;</span> -a -prune 为真），</span><br><span class="line">find命令将在除这个目录以外的目录下查找txt后缀文件并打印出来；</span><br><span class="line">如果目录dir0不存在（即-a左边为假），则不求值-prune ，<span class="string">&#x27;与&#x27;</span>逻辑表达式为假，则在当前目录下查找所有txt后缀文件。</span><br><span class="line"> </span><br><span class="line">5.在dir0、dir1及子目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ \( -path &quot;./dir0*&quot; -o -path &quot;./dir1*&quot; \)  -a -name &quot;*.txt&quot; -print</span></span><br><span class="line"> </span><br><span class="line">6.在除dir0、dir1及子目录以外的目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ \( -path &quot;./dir0*&quot; -o -path &quot;./dir1*&quot; \) -a -prune -o -name &quot;*.txt&quot; -print</span></span><br><span class="line">这里注意：</span><br><span class="line">圆括号()表示表达式的结合。即指示 shell 不对后面的字符作特殊解释，而留给 find 命令去解释其意义。由于命令行不能直接使用圆括号，</span><br><span class="line">所以需要用反斜杠<span class="string">&#x27;\&#x27;</span>进行转意(即<span class="string">&#x27;\&#x27;</span>转意字符使命令行认识圆括号)。同时注意<span class="string">&#x27;\(&#x27;</span>，<span class="string">&#x27;\)&#x27;</span>两边都需空格。</span><br><span class="line"> </span><br><span class="line">7. 在所有以名为dir_general的目录下查找txt后缀文件</span><br><span class="line"><span class="comment"># find ./ -path &quot;*/dir_general/*&quot; -name &quot;*.txt&quot; -print</span></span><br><span class="line"> </span><br><span class="line">8. 在当前目录下，过滤.git目录内容（.git目录本身也不要列出来），命令如下：</span><br><span class="line"><span class="comment"># find . -path ./.git -prune -o -print -a \( -type f -o -type l -o -type d \) | grep &#x27;.git&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>########## find文件搜索条件 ############</strong><br>-name、-iname、通配符*？、-size、-user、-group、-amin、-cmin、-mmin、-a、-o、-exec/-ok、-inum</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#find [搜索范围] [匹配条件]</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">1. 根据文件名称进行find检索</span><br><span class="line">find 命令中的 -name 选项可以根据文件名称进行检索（区分大小写）。如需要忽略文件名中的大小写，可以使用 -iname 选项。</span><br><span class="line">-name   区分大小写</span><br><span class="line">-iname  不分区大小写</span><br><span class="line">?    可以表示任意一个单一的符号</span><br><span class="line">*    可以表示任意数量（包括 0）的未知符号</span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /usr -name &#x27;*.txt&#x27;   #查找/usr目录下所有文件名以.txt结尾的文件</span></span><br><span class="line"><span class="comment">#find /usr -name &#x27;????&#x27;    #查找/usr目录下所有文件名刚好为4个字符的文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -name init</span></span><br><span class="line"><span class="comment">#find /etc -name *init*</span></span><br><span class="line"><span class="comment">#find /etc -name init???</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#touch /tmp/inIt</span></span><br><span class="line"><span class="comment">#mkdir /tmp/Init</span></span><br><span class="line"><span class="comment">#find /tmp -name init</span></span><br><span class="line"><span class="comment">#find /tmp -iname init    #不区分大小写</span></span><br><span class="line"><span class="comment">#find /tmp -iname ini*</span></span><br><span class="line"> </span><br><span class="line">有些时候，需要在搜索时匹配某个文件或目录的完整路径，而不仅仅是匹配文件名。可以使用 -path 或 -ipath 选项。</span><br><span class="line">如查找/usr下所有文件名以.txt结尾的文件或目录，且该文件的父目录必须是src。可以使用以下命令：</span><br><span class="line"><span class="comment">#find /usr -path &#x27;*/src/*.txt&#x27;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">2. 根据文件类型进行find检索</span><br><span class="line">如果只想搜索得到文件或目录，即不想它们同时出现在结果中。可以使用 -<span class="built_in">type</span> 选项指定文件类型。</span><br><span class="line">-<span class="built_in">type</span> 选项最常用的参数如下：</span><br><span class="line">f:   文件</span><br><span class="line">d:   目录</span><br><span class="line">l:   符号链接</span><br><span class="line"> </span><br><span class="line"><span class="comment"># find /usr -type d -name &#x27;python*&#x27;   #检索/usr下所有文件名以python开头的目录</span></span><br><span class="line"><span class="comment">#find /etc -name init* -type f</span></span><br><span class="line"><span class="comment">#find /etc -name init* -a -type d</span></span><br><span class="line"> </span><br><span class="line">-a 两个条件同时满足</span><br><span class="line">-o 两个条件满足一个即可</span><br><span class="line">-------------------------------------------------</span><br><span class="line">3. 根据文件大小进行find检索</span><br><span class="line">-size 选项允许用户通过文件大小进行搜索（只适用于文件，目录没有大小）。</span><br><span class="line"> </span><br><span class="line">表示文件大小的单位由以下字符组成：</span><br><span class="line">c：字节</span><br><span class="line">k：Kb</span><br><span class="line">M：Mb</span><br><span class="line">G：Gb</span><br><span class="line"> </span><br><span class="line">另外，还可以使用 + 或 - 符号表示大于或小于当前条件。</span><br><span class="line"><span class="comment">#find / -size +204800       #查找大于100M的文件</span></span><br><span class="line"><span class="comment">#find / -size -204800       #查找小于100M的文件</span></span><br><span class="line"><span class="comment">#find / -size 204800        #查找等于100M的文件</span></span><br><span class="line"><span class="comment">#find / -size +1G           #检索文件大小高于1GB的文件</span></span><br><span class="line"><span class="comment">#find / -size -10M          #检索文件大小小于10M的文件</span></span><br><span class="line"> </span><br><span class="line">204800单位是数据块</span><br><span class="line">1数据块=512字节=0.5K</span><br><span class="line">100MB = 102400KB</span><br><span class="line">100MB = 2048数据块</span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -size +163840 -a -size -204800   #查找大于80M小于100M的文件</span></span><br><span class="line"><span class="comment"># find / -size 50M</span></span><br><span class="line"><span class="comment"># find / -size +50M -size -100M</span></span><br><span class="line"><span class="comment"># find / -size +100M -exec rm -rf &#123;&#125; ;</span></span><br><span class="line"><span class="comment"># find / -type f -name *.mp3 -size +10M -exec rm &#123;&#125; ;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">4. 检索空文件</span><br><span class="line">find 命令支持 -empty 选项用来检索为空的文件或目录。空文件即文件里没有任何内容，空目录即目录中没有任何文件或子目录。</span><br><span class="line"><span class="comment"># find ~ -type d -empty    #检索用户主目录下所有的空目录</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">5. 反义匹配</span><br><span class="line">find 命令也允许用户对当前的匹配条件进行<span class="string">&quot;反义&quot;</span>（类似于逻辑非操作）。</span><br><span class="line">如需要检索 /usr 下所有文件名不以 .txt 为后缀的文件。可以使用以下命令：</span><br><span class="line"><span class="comment">#find /usr -type f ! -name &#x27;*.txt&#x27;</span></span><br><span class="line"> </span><br><span class="line">也可以<span class="string">&quot;翻转&quot;</span>任何其他的筛选条件，如：</span><br><span class="line"><span class="comment">#find /usr -type f ! -empty 检索 /usr 下所有内容不为空的文件</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">6. 根据文件的所属权进行find检索</span><br><span class="line"><span class="comment">#find / -type f -user starky  #检索根目录下所有属主为starky的文件</span></span><br><span class="line"><span class="comment">#find / -user root 在根目录下查找所有者为root的文件</span></span><br><span class="line"><span class="comment">#find / -group root 在根目录下查找所属组为root的文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># find / -user root -name tecmint.txt</span></span><br><span class="line"><span class="comment"># find /home -user tecmint</span></span><br><span class="line"><span class="comment"># find /home -group developer</span></span><br><span class="line"><span class="comment"># find /home -user tecmint -iname &quot;*.txt&quot;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">7. 根据时间日期进行find检索</span><br><span class="line"> </span><br><span class="line">修改时间（Modification time）：最后一次文件内容有过更改的时间点</span><br><span class="line">访问时间（Access time）：最后一次文件有被读取过的时间点</span><br><span class="line">变更时间（Change time）：最后一次文件有被变更过的时间点（如内容被修改，或权限等 metadata 被修改）</span><br><span class="line">与此对应的是 find 命令中的 -mtime，-atime 和 -ctime 三个选项。</span><br><span class="line"> </span><br><span class="line">这三个选项的使用遵循以下示例中的规则：</span><br><span class="line">-mtime 2： 该文件 2 天前被修改过</span><br><span class="line">-mtime -2：该文件 2 天以内被修改过</span><br><span class="line">-mtime +2：该文件距离上次修改已经超过 2 天时间</span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /usr -type f -mtime 2   #检索/usr下两天前被修改过的文件</span></span><br><span class="line"> </span><br><span class="line">如果觉得 -mtime 等选项以天为单位时间有点长，还可以使用 -mmin，-amin，-cmin 三个选项：</span><br><span class="line"><span class="comment">#find /usr -type f -mtime +50 -mtime -100    #检索/usr下50到100天之前修改过的文件</span></span><br><span class="line"><span class="comment">#find /usr -type f -mtime 2 -amin 5          #检索/usr下两天前被修改过且5分钟前又读取过的文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -amin 5    #查找5分钟之前被访问过的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -amin -5   #查找5分钟之内被访问过的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -amin +5   #查找距离上次被访问时间超过5分钟过的文件和目录</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -cmin 5    #查找5分钟之前被修改过属性的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -cmin -5   #查找5分钟之内被修改过属性的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -cmin +5   #查找距离上次被修改过属性超过5分钟的文件和目录</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -mmin 5    #查找5分钟之前被修改过内容的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -mmin -5   #查找5分钟之内被修改过内容的文件和目录</span></span><br><span class="line"><span class="comment">#find /etc -mmin +5   #查找距离上次被修改过内容超过5分钟的文件和目录</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">8. 根据文件权限进行find检索</span><br><span class="line">find 命令可以使用 -perm 选项以文件权限为依据进行搜索。</span><br><span class="line"> </span><br><span class="line">使用符号形式</span><br><span class="line">如需要检索 /usr 目录下权限为 rwxr-xr-x 的文件，可以使用以下命令：</span><br><span class="line"><span class="comment"># find /usr -perm u=rwx,g=rx,o=rx</span></span><br><span class="line"> </span><br><span class="line">搜索/usr目录下所有权限为 r-xr-xr-x（即系统中的所有用户都只有读写权限）的文件和目录，可以使用以下命令：</span><br><span class="line"><span class="comment">#find /usr -perm a=rx</span></span><br><span class="line"> </span><br><span class="line">很多时候，只想匹配文件权限的一个子集。比如，检索可以直接被任何用户执行的文件，即只关心文件的执行权限，而不用管其读写权限是什么。</span><br><span class="line">上述的需求可以通过以下命令实现：</span><br><span class="line"><span class="comment">#find / -type f -perm /a=x</span></span><br><span class="line">其中 a=x 前面的 / 符号即用来表示只匹配权限的某个子集（执行权限），而不用关心其他权限的具体设置。</span><br><span class="line"> </span><br><span class="line">使用数字形式</span><br><span class="line">-perm 选项也支持数字形式的文件权限标记。</span><br><span class="line"><span class="comment"># find /usr -perm 644     #搜索/usr目录下权限为 644（即 rwxr-xr-x）的文件</span></span><br><span class="line"> </span><br><span class="line"><span class="comment"># find . -type f -perm 0777 -print</span></span><br><span class="line"><span class="comment"># find / -type f ! -perm 777</span></span><br><span class="line"><span class="comment"># find / -perm 2644</span></span><br><span class="line"><span class="comment"># find / -perm 1551</span></span><br><span class="line"><span class="comment"># find / -perm /u=s</span></span><br><span class="line"><span class="comment"># find / -perm /g+s</span></span><br><span class="line"><span class="comment"># find / -perm /u=r</span></span><br><span class="line"><span class="comment"># find / -perm /a=x</span></span><br><span class="line"><span class="comment"># find / -type f -perm 0777 -print -exec chmod 644 &#123;&#125;\;</span></span><br><span class="line"><span class="comment"># find / -type d -perm 777 -print -exec chmod 755 &#123;&#125;\;</span></span><br><span class="line"><span class="comment"># find . -type f -name &quot;tecmint.txt&quot; -exec rm -f &#123;&#125; \;</span></span><br><span class="line"><span class="comment"># find . -type f -name &quot;*.txt&quot; -exec rm -f &#123;&#125; \;</span></span><br><span class="line"><span class="comment"># find . -type f -name &quot;*.mp3&quot; -exec rm -f &#123;&#125; \;</span></span><br><span class="line"><span class="comment"># find /tmp -type f -empty</span></span><br><span class="line"><span class="comment"># find /tmp -type d -empty</span></span><br><span class="line"><span class="comment"># find /tmp -type f -name &quot;.*&quot;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">9. 限制遍历的层数（这个在上面文章已经详细介绍）</span><br><span class="line">find 命令默认是以递归的方式检索项目的，这有时候会导致得到的结果数量非常巨大。可以使用 -maxdepth 限制 find 命令递归的层数。</span><br><span class="line"><span class="comment"># find / -maxdepth 3 搜索时向下递归的层数最大为 3</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">10. 逻辑组合</span><br><span class="line">在之前的例子中有出现多个搜索条件的组合以及对某个搜索条件的反转。</span><br><span class="line">实际上 find 命令支持 <span class="string">&quot;and&quot;</span> 和 <span class="string">&quot;or&quot;</span> 两种逻辑运算，对应的命令选项分别是 -a 和 -o。通过这两个选项可以对搜索条件进行更复杂的组合。</span><br><span class="line"> </span><br><span class="line">此外还可以使用小括号对搜索条件进行分组。注意 find 命令中的小括号常需要用单引号包裹起来。因小括号在 Shell 中有特殊的含义。</span><br><span class="line"> </span><br><span class="line">如检索 /usr 下文件名以 python 开头且类型为目录的文件</span><br><span class="line"><span class="comment">#find /usr -type d -name &#x27;python*&#x27;</span></span><br><span class="line">该命令等同于：</span><br><span class="line"><span class="comment">#find /usr -type d -a -name &#x27;python*&#x27;</span></span><br><span class="line">更复杂的组合形式如：</span><br><span class="line"><span class="comment">#find / &#x27;(&#x27; -mmin -5 -o -mtime +50 &#x27;)&#x27; -a -type f</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">11. -<span class="built_in">exec</span> <span class="built_in">command</span> &#123;&#125; \;  以及 -ok <span class="built_in">command</span> &#123;&#125; \; 用法</span><br><span class="line"><span class="comment">#find /etc -name inittab -exec ls -l &#123;&#125; \;     #查找inittab文件并显示其详细信息</span></span><br><span class="line">在&#123;&#125;和\之间要有一个空格</span><br><span class="line">-<span class="built_in">exec</span>跟&#123;&#125;\; 之间执行的是对搜索结果进行的操作动作</span><br><span class="line"> </span><br><span class="line"><span class="comment">#find /etc -name inittab -a -type f -exec ls -l &#123;&#125; \;</span></span><br><span class="line"><span class="comment">#touch /tmp/testfile.rm</span></span><br><span class="line"><span class="comment">#find /tmp -name testfile.* -exec rm &#123;&#125; \;</span></span><br><span class="line"> </span><br><span class="line">-ok等同于-<span class="built_in">exec</span></span><br><span class="line">-ok跟&#123;&#125;\; 之间执行的是对搜索结果进行的操作动作</span><br><span class="line">和-<span class="built_in">exec</span>不同的地方在于有一个询问，需要输入y或n确认</span><br><span class="line"><span class="comment">#find /etc -name init* -ok rm -l &#123;&#125; \;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">12. 根据inode节点进行find检索</span><br><span class="line"><span class="comment">#find /etc -inum xxx     #根据I节点查找</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#touch &quot;test 000&quot;</span></span><br><span class="line"><span class="comment">#ls -i</span></span><br><span class="line"><span class="comment">#find . -inum 396401 -exec rm &#123;&#125; \;</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">#touch test999</span></span><br><span class="line"><span class="comment">#ln test999 test9999</span></span><br><span class="line"><span class="comment">#ls -i test999</span></span><br><span class="line"><span class="comment">#find . -inum 396401 -exec ls -l &#123;&#125; \;</span></span><br><span class="line">-------------------------------------------------</span><br><span class="line">13. 对搜索结果执行命令</span><br><span class="line">1）删除文件</span><br><span class="line">-delete 选项可以用来删除搜索到的文件和目录。</span><br><span class="line"> </span><br><span class="line">如删除 home 目录下所有的空目录：</span><br><span class="line"><span class="comment"># find ~ -type d -empty -delete</span></span><br><span class="line"> </span><br><span class="line">2）执行自定义命令</span><br><span class="line">-<span class="built_in">exec</span> 选项可以对搜索到的结果执行特定的命令。</span><br><span class="line"> </span><br><span class="line">如需要将home目录下所有的MP3音频文件复制到移动存储设备（假设路径是/media/MyDrive），可使用下面的命令：</span><br><span class="line"><span class="comment">#find ~ -type f -name &#x27;*.mp3&#x27; -exec cp &#123;&#125; /media/MyDrive &#x27;;&#x27;</span></span><br><span class="line"> </span><br><span class="line">上面命令中的大括号&#123;&#125;作为检索到的文件的占位符 ，而分号;作为命令结束的标志。因为分号是Shell中有特殊含义的符号，所以需要使用单引号括起来。</span><br><span class="line">每当find命令检索到一个符合条件的文件，会使用其完整路径取代命令中的 &#123;&#125;，然后执行 -<span class="built_in">exec</span> 后面的命令一次。</span><br><span class="line"> </span><br><span class="line">另一个很重要的用法是，在多个文件中检索某个指定的字符串。</span><br><span class="line">如在用户主目录下的所有文件中检索字符串 hello ，可以使用如下命令：</span><br><span class="line"><span class="comment"># find ~ -type f -exec grep -l hello &#123;&#125; &#x27;;&#x27;</span></span><br><span class="line"> </span><br><span class="line">-<span class="built_in">exec</span> 选项中的 + 符号</span><br><span class="line">现在假设需要将用户主目录下所有的MP3文件添加到压缩包 music.tar.gz 中，直观的感觉是，其命令应为如下形式：</span><br><span class="line"><span class="comment">#find ~ -type f -name &#x27;*.mp3&#x27; -exec tar -czvf music.tar.gz &#123;&#125; &#x27;;&#x27;</span></span><br><span class="line"> </span><br><span class="line">实际情况是，上面命令得到的music.tar.gz 其实只包含一个MP3文件。</span><br><span class="line">原因是find命令每次发现一个音频文件，都会再执行一次-<span class="built_in">exec</span>选项后面的压缩命令。导致先前生成的压缩包被覆盖。</span><br><span class="line"> </span><br><span class="line">可以先让find命令检索出所有符合条件的音频文件，再将得到的文件列表传递给后面的压缩命令。所以正确完整的命令如下：</span><br><span class="line"><span class="comment">#find ~ -type f -name &#x27;*.mp3&#x27; -exec tar -czvf music.tar.gz &#123;&#125; +</span></span><br><span class="line"> </span><br><span class="line">3）显示文件信息</span><br><span class="line">如果想浏览搜索到的文件（目录）的详细信息（如权限和大小等），可以直接使用-ls选项。</span><br><span class="line"><span class="comment">#find / -type file -size +1G -ls    #浏览所有 1G 以上大小的文件的详细信息</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>Linux 两个文件求交集、并集、差集</title>
    <url>/2021/05/21/Linux-%E4%B8%A4%E4%B8%AA%E6%96%87%E4%BB%B6%E6%B1%82%E4%BA%A4%E9%9B%86%E3%80%81%E5%B9%B6%E9%9B%86%E3%80%81%E5%B7%AE%E9%9B%86/</url>
    <content><![CDATA[<h1 id="一、交集"><a href="#一、交集" class="headerlink" title="一、交集"></a>一、交集</h1><p>sort a.txt b.txt | uniq -d</p>
<h1 id="二、并集"><a href="#二、并集" class="headerlink" title="二、并集"></a>二、并集</h1><p>sort a.txt b.txt | uniq </p>
<h1 id="三、差集"><a href="#三、差集" class="headerlink" title="三、差集"></a>三、差集</h1><p>a.txt-b.txt:</p>
<p>sort a.txt b.txt b.txt | uniq -u</p>
<p>b.txt - a.txt:</p>
<p>sort b.txt a.txt a.txt | uniq -u</p>
<a id="more"></a>

<h1 id="四、相关的解释"><a href="#四、相关的解释" class="headerlink" title="四、相关的解释"></a>四、相关的解释</h1><p>使用sort可以将文件进行排序，可以使用sort后面的玲玲，例如 -n 按照数字格式排序，例如 -i 忽略大小写，例如使用-r 为逆序输出等</p>
<p>uniq为删除文件中重复的行，得到文件中唯一的行，后面的命令 -d 表示的是输出出现次数大于1的内容 -u表示的是输出出现次数为1的内容，那么对于上述的求交集并集差集的命令做如下的解释：</p>
<p>sort a.txt b.txt | uniq -d：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，使用-d输出两个文件中次数大于1的内容，即是得到交集</p>
<p>sort a.txt b.txt | uniq ：将a.txt b.txt文件进行排序，uniq使得两个文件中的内容为唯一的，即可得到两个文件的并集</p>
<p>sort a.txt b.txt b.txt | uniq -u：将两个文件排序，最后输出a.txt b.txt b.txt文件中只出现过一次的内容，因为有两个b.txt所以只会输出只在a.txt出现过一次的内容，即是a.txt-b.txt差集</p>
<p>对于b.txt-a.txt为同理</p>
]]></content>
      <categories>
        <category>shell</category>
      </categories>
  </entry>
  <entry>
    <title>Mr. Process的一生－Linux内核的社会视角 (1)调度 (转)</title>
    <url>/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-1-%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<p>转自：<a href="http://manio.org/2010/01/08/scheduling-of-linux-view-of-society.html">http://manio.org/2010/01/08/scheduling-of-linux-view-of-society.html</a></p>
<p>Linux内核是一个无比复杂的系统，要想看清大致的脉络也非易事。其实，可以把运行中的Linux想像成一个人类的社会，当中的进程就是社会中的人。人有生老病死，进程有创建、异常、终止。人有各种各样的财产，进程有对应的地址空间、设备等等。人被各种各样的东西限制着，被人管着，进程也是。内核无比巨大，从哪着手？我想，从进程的视角来看是个好办法。并且，在学习Linux内核的同时，类比人类社会来看，会有更深刻的印象，理解得更透彻。</p>
<p>本来也应该从进程的创建开始写的，但是最近在看调度的相关论文，就又把Linux调度的东西看了一下。所以，就先写调度相关的东西吧。</p>
<a id="more"></a>

<p>首先介绍与进程所在环境对应的人类场景：</p>
<p>这是一个公司，公司里有很多人（进程），每个人都有其对应的职称（优先级）。这个公司很奇怪，只有一张办公桌（CPU），在任意时刻，只能有一个人在工作(TASK_RUNNING正在运行状态)。其他人呢，要么在休息室时短暂地休息（对应TASK_RUNNING就绪状态），要么就在寝室Sleep(对应TASK_INTERRUPTABLE或TASK_UNINTERRUPTABLE)，要么就是死人了，在停尸间（TASK_ZOMBIE）。是的，这是真的，这个公司就是个血汗工厂，干活累死了，就直接丢进停尸间，惨绝人寰！</p>
<p>以下是此公司的平面图：</p>
<img src="/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-1-%E8%B0%83%E5%BA%A6/RoomScale1.png" class="" title="roomscale1">

<p>图解：“推门”是单向的：比如连接工作室和太平间的是推门，职员只能从工作室走到太平间，不能从太平间走到工作室（这太吓人了）。“凹槽门”是双向的：比如连接工作室和休息室的门是凹槽门，职员可以走来走去。</p>
<p><strong>时间片</strong>(time slice)：这个公司的工资特别高，按工作的小时数计算。工作者得钱，不工作者不得钱。所以，所有的人都特想去办公桌那里工作，争着抢着要去。为了让大家都有机会去工作（避免有的人没钱拿，饿死，i.e. starve to death），所以公司出了条规定，每个人每次工作的时间不能超过公司分给自己的时间片（time slice）。时间片的大小由此人的职称决定。</p>
<p><strong>职称</strong>（也就是内核中的priority）：职称有两种，一种是静态职称（static priority），一种是动态职称（dynamic priority）。静态职称是先天的，由此人的老爸决定（富二代有先天优势！）。动态优先级是看在公司里的工作表现的。职称是很重要的东西，职称越高，你到办公桌上赚钱的机会越大。</p>
<p><strong><em>默认时间片长点好还是短点好？\</em></strong></p>
<p><em>自然是不长不短好（世界上的事情都是这样）。如果太短了，比如说某职员时间片是1<strong>分钟（对应的Linux</strong>里的时间片应该差不多是0.1ms**吧，可能还得少点），这个人在办公桌前屁股没坐热就要走了，从起身到回到休息室，再到下一个人起身走到办公桌前坐下，这也得要一分钟。如果这样的话，这公司将有一半的时间花在走路上。这样搞是不行的，在资本主义社会，大家都要努力搞高生产率。</em></p>
<p><em>那是不是时间片长了就好？也不是。比如时间片是一个小时，当两个客户（对应Linux<strong>中的两个用户）同时要和此公司展开业务（对应Linux</strong>中的启动进程），有两个职员会分别处理这两个业务。A<strong>职员一上去就占着办公室一个小时，B</strong>职员在这一个小时结束前没法子处理他的客户的业务，所以B**职员的客户就得在寒风中等一个小时！资本主义社会里的公司是不能让他们的财神爷不高兴的。所以，还是不长不短的好。</em></p>
<p><em>回到真实的Linux<strong>内核中:**很多人认为时间片过长会导致程序的响应（比如字处理程序的I/O</strong>响应）变慢，因为要等时间片用完才能处理。其实不然，字处理程序等交互性强的程序,<strong>他们的优先级高，可以抢占当前正在运行的进程，从而得到执行。在公司里，就比如B</strong>职员的职称高，他可以把A<strong>职员从办公桌上踢走。事实上，从后面对动态优先级的讨论我们可以看到，要是A</strong>职员一直霸占着办公桌不走，他/<strong>她的动态职称会变低的，结果是，在休息室里的其他职员的职称就自然而然地可能比A</strong>高了。</em></p>
<p>**职员目录(Process list)**：公司有个目录，在这个目录中，列出了所有公司的职员。这对应Linux里的Process List，里面存有所有进程的信息。</p>
<h2 id="下面以Mr-P的经历为例说明"><a href="#下面以Mr-P的经历为例说明" class="headerlink" title="下面以Mr. P的经历为例说明"></a>下面以Mr. P的经历为例说明</h2><p>Personal History Statement of Mr. Process （Mr. P in short）</p>
<h3 id="出生"><a href="#出生" class="headerlink" title="出生"></a>出生</h3><p>这是世界上最怪异的公司，职员都是单性的，都是男的。并且不要交配，自己调用系统调用fork()，就可以生了。生出来的小孩子也都是男的。</p>
<p>在这里为了问题的简化，就只讨论与调度的关系比较紧密的内容。</p>
<img src="/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-1-%E8%B0%83%E5%BA%A6/roomscale_addedQueue1.png" class="" title="image">

<p>图：详细的公司平面图</p>
<p>如上图所示，在休息室里其实还有两个沙发。一个沙发叫做活动队列（往后我们叫它<strong>活动沙发</strong>吧），一个沙发叫做过期队列（往后我们叫它<strong>过期沙发</strong>）。坐在活动沙发上的职员都还有时间片没有用完，坐在过期沙发上的职员的时间片刚刚被用完了（但他们手上都拿着新分配到的时间片，这个是2.5版内核新引入的O(1)调度，后面再讲）。</p>
<p>Mr. P的父亲在办公桌旁边工作的时候，突然fork()了一下，就生出了Mr.P。一出生，Mr. P就拥有和父亲一样的静态职称（static priority）。他一出生就坐在了活动沙发上，拿走了父亲一半的时间片。比如生MR. P之前，MR. P的父亲有10ms的时间片，MR.P出生后，他父亲有5ms，Mr. P有5ms。这样的机制是为了防止有人以生子来抢夺时间片：试想，有一人，自己有10ms的时间片，他一直生啊生，生了100个孩子，那么这个程序就有了10+10*100ms的时间片了。然后他的孩子断续生啊生，那么有可能系统中绝大部分的时间片都是他家的了，那他的街坊邻居还要不要活啊，没时间片等于不能做事，等于没工资，等于没食物，等于饿死。</p>
<p>另外，不幸的是，即使是在发达的资本主义社会，孩子也是有可能夭折的（由于各种原因，在第一次到办公桌上工作之前就死掉了）。在这种情况下，公司会把孩子没用的时间片还给他父亲。多么人性化的公司…</p>
<h3 id="开始工作"><a href="#开始工作" class="headerlink" title="开始工作"></a>开始工作</h3><p>像其他所有孩子一样，Mr. P一生下来就<strong>能</strong>工作了，他坐在活动沙发上等着做事。他人事部的同事Miss Schedule (以下简称Miss S)会在每个tick(内核的时间单位，时间很短)结束时检查一下以下两种情况有没有发生：</p>
<ol>
<li>在办公桌前工作的那个职员是不是已经用完自己的时间片了。</li>
<li>是不是有更高动态职称（dynamic priority）的职员在活动沙发上等着。</li>
</ol>
<p>其中一种情况成立，这个在办公桌前工作的那个职员就要被赶出来，换在活动沙发上坐着的动态职称最高的职员进去工作。</p>
<p>假设经过一段时间后，没有人的动态职称比Mr. P高了。在一个时间tick结束时，Miss S到休息室检查大家当前的职称。他能轻松地找到动态职称最高的职员(sched_find_first)，因为职员们都是按动态职称来坐的（在活动沙发上），动态职称相同的职员坐在一起（参考struct prio_array）。Miss S只要按顺序找下去，第一个在沙发上找到的职员就是职称最高的。当Miss S用上面的方法发现Mr. P当前的动态职称是最高的时，在办公桌前工作的是职员C，Miss S把C从办公桌前拉到休息室。如果此时C的时间片已经用完了，他就会被安排坐在过期沙发上（这也就是expired的含义）；如果此时C的时间片没有用完，他就会被安排坐在活动沙发上。C被拉到休息室时，他的工作用具，笔啊纸啊什么的，都要从办公桌上拿走（这是关于进程上下文切换的问题）。C走了之后，Mr. P带着他的东西到办公桌前坐下，整理好办工用品（进程上下文切换）。好的，Mr. P可以开始工作了。</p>
<h3 id="评定动态职称"><a href="#评定动态职称" class="headerlink" title="评定动态职称"></a>评定动态职称</h3><p><strong>公司里的两类人：</strong></p>
<p><strong>交际花</strong>（I/O消耗型进程）：这类人常常与外部的客户打交道，而客户的反应总是不怎么快。所以，交际花常常要等客户做出反应。公司为了不让交际花在等客户反应的时候也占用着办公桌，所以，当交际花要等待客户的响应时，他就会被移到寝室去睡觉(Sleep)。</p>
<p><strong>工作狂</strong>（处理器消耗型）：这类人就是传说中的苦干王，很少和外界打交道，就知道在办工桌上做事。这种工作狂给公司造成一些困扰，如果他们老占着办公桌，交际花就没法做事了。要知道，一个公司还是需要人去跑跑业务的。</p>
<p>公司有一套机制，这一套机制能很好的区分这两类人，并且给他们评定职称。判断的标准就是他们的平均睡眠时间（average sleep time）。睡眠时间包括在寝室里的时间（TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE）和在休息室时等待的时间。但平均睡眠时间的计算并不是加和再求平均那么简单。在TASK_INT和TASK_UNINT两种状态下，平均睡眠时间的增长情况是不一样的。在运行的时间，平均睡眠时间是在减少的。具体的平均睡眠时间的算法在recalc_task_prio()中。</p>
<p>当一个职员常常睡觉，公司就知道这人是交际花了，因为他常常因为等客户的响应而睡觉。当一个职员很少睡觉，公司就知道这人是个工作狂了，因为他很少因为等客户的响应而睡觉。</p>
<p>现在我们回来讨论Mr. P，假设Mr. P在工作的时候要等待一个客户给数据给他(比如说键盘数据)，他就把自己的加入一个等待队列里，将自己设为TASK_INT，这样他就进入了寝室里。Mr. P在那里苦苦地等待他要的数据到来。终于，客户敲下了键盘，给出了数据。然后键盘事件的管理者调用wake_up()函数，将Mr. P唤醒。如果Mr. P的动态职称高于当前正在工作的职员的动态职称，那么Mr. P就会抢掉这个职员的办公桌。如果不高于的话，Mr. P就只是先到休息室里坐着。我们假设Mr. P的动态职称很高，所以，现在Mr. P又抢到了办公桌。</p>
<h3 id="O-1-调度"><a href="#O-1-调度" class="headerlink" title="O(1)调度"></a>O(1)调度</h3><p>又过了一段时间，Mr. P的时间片用完了，该离开了。这时他该被Miss S带到过期沙发上了，在从办公桌走到过期沙发的路上，Miss S会帮他重新算时间片（依照动态职称来决定时间片的长短）。事实上，每个职员被带到过期沙发上坐着的时候，Miss S都会帮他算好时间片。这样，过期沙发上的所有职员手中都拿着时间片。这样做的好处是，当活动沙发空了的时间，只要把活动沙发和过期沙发上贴着的“活动沙发”和“过期沙发”的标签互换一下，原来的过期沙发就变成了活动沙发，原来的活动沙发就变成了过期沙发。这样，Miss S就又可以从活动沙发上叫人去工作了。而这个“互换标签”的动作的时间复杂度是O(1)。这就是2.5版内核所引入的O(1)调度。</p>
<p>试想一下没有这个O(1)调试之前是什么情况：每次所有进程的时间片都用完时，要重新计算所有TASK_RUNNING状态的进程的时间片。当一个系统中只有几个进程的情况还好，但是对于有成千上万个进程的大型系统，这是相关耗时的。</p>
<h3 id="对交际花的优惠政策"><a href="#对交际花的优惠政策" class="headerlink" title="对交际花的优惠政策"></a>对交际花的优惠政策</h3><p>在一个公司来说，交际花是非常重要的，他们的表现直接关系到客户的满意度和公司的形象。所以，Linux公司有一些专门针对交际花的优惠政策。</p>
<p>假设Mr. P就是一个十足的交际花：上班打扮得花枝招展（虽然是个男的），见人说人话见鬼说鬼话，关键是，他有一些客户特别爱和他把交道。当Mr. P用完一个时间片的时候，照常理，他是应该被Miss S带到过期沙发上去等待下一次工作的。但这样的等待有可能太久了－要等到所有活动沙发上的职员都用完时间片。所以，Miss S为了客户的满意度（如果等太久，客户是不满意的），就在重新计算Mr. P的时间片之后，让他留在了活动沙发上。这样，Mr. P就能更快地处理客户的IO事件。</p>
<p>这看起来是对交际花的特权，其实这是为了公司的长远利益着想。如果客户的需求得不到及时的满足，客户不满意，就不会有人用这公司的产品了，即使工作狂们的工作做得很好。</p>
<h3 id="公司里的超级特权阶级－小霸王-real-time-process"><a href="#公司里的超级特权阶级－小霸王-real-time-process" class="headerlink" title="公司里的超级特权阶级－小霸王(real-time process)"></a>公司里的超级特权阶级－小霸王(real-time process)</h3><p>交际花是有一些特权，但权利再大也大不过小霸王。公司有时会有一些时间很紧的项目要做，这些项目有deadline。为了能完成这些重要的项目，公司里发展了一种特权阶级，就是小霸王。他们的职称高于其他所有普通员工，除非他们完成了自己的工作，否则其他职工不能去工作。</p>
<p>这些小霸王的工作方式有两种：</p>
<p>FIFO(First In First Out)：当一个小霸王完成自己工作的时间，其他小霸王才能去工作。但是当有职称更高的小霸王到来时，职称更高的小霸王能抢占当前的小霸王的办公桌。</p>
<p>RR(Route Robin)：相同优先级的小霸王转着用办公桌，每人用一段时间。</p>
<h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><p>在这篇文章里，以Mr. P的工作经历来说明了Linux调度的一些比较重要的机制。介绍了IO消耗型进程和处理器消耗型的进程，O(1)调度等等。这些是比较大的方面，当大的方面理解了之后，那些世界顶尖高手写的源码也就更容易看懂一些了。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>Mr. Process的一生－Linux内核的社会视角 (2)启动(转)</title>
    <url>/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-2-%E5%90%AF%E5%8A%A8/</url>
    <content><![CDATA[<p>其实这才应该是这一系列文章的第一节，因为这篇文章讲的是盘古开天地的事。话说Mr. Process是一个现代人，但是，只要是人，总该有个祖先。人们总想知道自己从哪来，然后才可以估摸算一下自己将去向何方。所以咱也要了解一下Linux的世界里人类的起源。</p>
<img src="/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-2-%E5%90%AF%E5%8A%A8/09145008_NbsI.gif" class="" title="img">

<p>图1：从上电到BIOS</p>
<a id="more"></a>

<p>按下电源开关的那个真实的人就是Linux世界里的上帝，他创造了Linux世界的一切。当他按下机箱上的电源开关时，主板开始供电，CPU上的Reset Pin被拉高，这会引起CPU的一系列动作，这些动作是芯片设计时就决定的。CPU中的一些寄存器被置为固定的值，因为这些寄存器可能在启动的过程中要使用，比如CS（代码段寄存器）和EIP（指针指令寄存器）。这一步完成之后，CPU就可开执行地址为0xfffffff0里的ROM中的程序。这段程序就是BIOS(Basic Input Output System)。</p>
<h3 id="BIOS完成下面的功能："><a href="#BIOS完成下面的功能：" class="headerlink" title="BIOS完成下面的功能："></a>BIOS完成下面的功能：</h3><p>1.POST（Power-On Self Test）：顾名思名，就是查查有什么设备，这些设备是不是正常。要是CPU有Advanced Configuration and Power Interface(ACPI )的支持，也在这个时候进行。ACPI是用来对电源进行管理的，用来节电之类的。</p>
<p>2.初始化设备：确保没有IRQ和IO冲突。</p>
<p>3.寻找OS/Bootloader。这一步后面点再细说</p>
<p>我们在BIOS的设置菜单里能够设置从何处启动，比如软盘，硬盘，光驱…BIOS会按我们设定的顺序搜索OS。</p>
<p>4.把Bootloader复制到RAM里（地址为0x00007c00），然后那个地址开始执行。</p>
<p><strong><em>什么是Bootloader？\</em></strong></p>
<p><em>现在，我们只要关心的是：bootloader会找到OS，把OS内核COPY到RAM中。</em></p>
<img src="/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-2-%E5%90%AF%E5%8A%A8/09145008_I1mI.gif" class="" title="img">

<p>图2：boot loader的加载</p>
<p>如上图所示，在硬盘的第一个sector，有一个分区表（记录了哪些分区上有操作系统）和一个小版的Bootloader。当这个BIOS被设置为从这里启动时，这个小版的bootloader被复制到RAM的0x00007c00。然后它会把自己又移动到0x00096a00。在这之后，它再把另一段Bootloader从硬盘上复制到0x00096c00，然后从那里开始执行。分作两段的原因是因为现在的bootloader太大了，在MBR上存不完那么多。</p>
<p>Bootloader会把OS的内核映像复制到RAM中。</p>
<h3 id="Bootloader的工作"><a href="#Bootloader的工作" class="headerlink" title="Bootloader的工作"></a>Bootloader的工作</h3><p>\1. 调用BIOS以显示“Loading Image”的消息。</p>
<p>\2. 调用BIOS，把内核映像的前512字节复制到0×00090000，setup()函数在0×00090200。</p>
<p>\3. 调用BIOS，把剩下的内核映像加载到0×00010000（小内核zImage）或0×00100000（大内核bzImage）</p>
<p>\4. 跳到setup()开始执行。</p>
<h3 id="Setup-的工作"><a href="#Setup-的工作" class="headerlink" title="Setup()的工作"></a>Setup()的工作</h3><p>setup()用来初始化设备。虽然BIOS已经做了一些初始化的工作，但是Linux关不依赖于他。setup()会初始化键盘，FPU等设备，并设置一些寄存器。在Setup()的最后，会调用startup_32()。</p>
<p>startup_32()</p>
<p>Linux里有两个startup_32()。</p>
<p>首先会执行的是<em>arch/i386/boot/compressed/head.S</em>里的那个。这个startup_32()的作用主要是解压内核。</p>
<p>第二个startup_32()是在<em>arch/i386/kernel/head.S</em>的。这个startup_32()的工作就是为Linux的第一个进程（就是Mr. Process的祖先）设置生存环境。最后跳到start_kernel()中去。</p>
<p>在Understanding the Linux Kernel 3rd 中的描述如下</p>
<ol>
<li>Initializes the segmentation registers with their final values.</li>
<li>Fills the bss segment of the kernel (see the section “Program Segments and Process Memory Regions” in Chapter 20) with zeros.</li>
<li>Initializes the provisional kernel Page Tables contained in <code>swapper_pg_dir</code> and <code>pg0</code> to identically map the linear addresses to the same physical addresses, as explained in the section “Kernel Page Tables” in Chapter 2.</li>
<li>Stores the address of the Page Global Directory in the <code>cr3</code> register, and enables paging by setting the <code>PG</code> bit in the <code>cr0</code> register.</li>
<li>Sets up the Kernel Mode stack for process 0 (see the section “Kernel Threads” in Chapter 3).</li>
<li>Once again, the function clears all bits in the <code>eflags</code> register.</li>
<li>Invokes <code>setup_idt( )</code> to fill the IDT with null interrupt handlers (see the section “Preliminary Initialization of the IDT” in Chapter 4).</li>
<li>Puts the system parameters obtained from the BIOS and the parameters passed to the operating system into the first page frame (see the section “Physical Memory Layout” in Chapter 2).</li>
<li>Identifies the model of the processor.</li>
</ol>
<p>\10. Loads the <code>gdtr</code> and <code>idtr</code> registers with the addresses of the GDT and IDT tables.</p>
<p>\11. Jumps to the <code>start_kernel( )</code> function.</p>
<h3 id="start-kernel-的工作"><a href="#start-kernel-的工作" class="headerlink" title="start_kernel()的工作"></a>start_kernel()的工作</h3><p>完成所有组件的初始化工作。</p>
<p><em>Understanding the Linux Kernel</em>对这一段工作的描述如下：</p>
<p>¨  The scheduler is initialized by invoking the sched_init( ) function (see Chapter 7).</p>
<p>¨  The memory zones are initialized by invoking the build_all_zonelists( ) function (see the section “Memory Zones” in Chapter 8).</p>
<p>¨  The Buddy system allocators are initialized by invoking the page_alloc_init( ) and mem_init( ) functions (see the section “The Buddy System Algorithm” in Chapter 8).</p>
<p>¨  The final initialization of the IDT is performed by invoking trap_init( ) (see the section “Exception Handling” in Chapter 4) and init_IRQ( ) (see the section “IRQ data structures” in Chapter 4).</p>
<p>¨  The TASKLET_SOFTIRQ and HI_SOFTIRQ are initialized by invoking the softirq_init( ) function (see the section “Softirqs” in Chapter 4).</p>
<p>¨  The system date and time are initialized by the time_init( ) function (see the section “The Linux Timekeeping Architecture” in Chapter 6).</p>
<p>¨  The slab allocator is initialized by the kmem_cache_init( ) function (see the section “General and Specific Caches” in Chapter 8).</p>
<p>¨  The speed of the CPU clock is determined by invoking the calibrate_delay( ) function (see the section “Delay Functions” in Chapter 6).</p>
<p>¨  The kernel thread for process 1 is created by invoking the kernel_thread( ) function. In turn, this kernel thread creates the other kernel threads and executes the /sbin/init program, as described in the section “Kernel Threads” in Chapter 3.</p>
<p>以上几个函数的执行过程如下图：</p>
<img src="/2021/05/03/Mr-Process%E7%9A%84%E4%B8%80%E7%94%9F%EF%BC%8DLinux%E5%86%85%E6%A0%B8%E7%9A%84%E7%A4%BE%E4%BC%9A%E8%A7%86%E8%A7%92-2-%E5%90%AF%E5%8A%A8/09145009_XKUA.gif" class="" title="img">

<p>图3：启动函数的执行过程</p>
<p>第二个startup_32()和start_kernel()揭示了Linux一生的真谛。从这里面咱看到了Mr. Process（一个普通的进程）所拥有的一切是怎么得到的。弄清楚了这些，也就弄清楚了Linux。Really清楚。</p>
<p>BTW，我做的图怎么那么好看~美感天生在那里，你挡都挡不住，怎么搞怎么好看加专业！</p>
]]></content>
  </entry>
  <entry>
    <title>kindle使用记录</title>
    <url>/2021/05/07/kindle%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="禁止ota升级"><a href="#禁止ota升级" class="headerlink" title="禁止ota升级"></a>禁止ota升级</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">First of all, the device needs to be jail broken.</span><br><span class="line">1. ssh to the device through either wifi or usbnet. I <span class="keyword">do</span> not see a difference here.</span><br><span class="line">2. mntroot rw</span><br><span class="line">3. <span class="built_in">cd</span> /usr/bin</span><br><span class="line">4. mv otaupd otaupd.bck</span><br><span class="line">5. mv otav3 otav3.bck</span><br><span class="line">6. ps aux | grep ota</span><br><span class="line">You will see four processes here. Ignore the <span class="string">&quot;/usr/java/bin/cvm&quot;</span> and <span class="string">&quot;grep ota&quot;</span>.</span><br><span class="line">The second column is the process id, note down the ids of the other two processes, otav3 and otaupd.</span><br><span class="line">7. pkill &#123;the id <span class="keyword">in</span> the output of the last <span class="built_in">command</span>&#125;</span><br><span class="line">8. pkill &#123;the other id <span class="keyword">in</span> the output of the last <span class="built_in">command</span>&#125;</span><br><span class="line">or instead of pkill, use reboot <span class="built_in">command</span> to reboot the device. Then you will know <span class="keyword">if</span> these two processes would be restarted after reboot.</span><br><span class="line"></span><br><span class="line">The otav3 seems like <span class="string">&quot;ota&quot;</span> <span class="string">&quot;v3&quot;</span>; I am not sure <span class="keyword">if</span> it has been changed to v4 recently.</span><br><span class="line"></span><br><span class="line">Indeed you <span class="keyword">do</span> not need to use ssh, <span class="keyword">if</span> you have koreader, use the terminal simulator <span class="keyword">in</span> the plugin can <span class="keyword">do</span> pretty much the same thing.</span><br></pre></td></tr></table></figure>

<a id="more"></a>]]></content>
      <categories>
        <category>kindle</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2021/06/17/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h1 id="拜托，不要再问我Git如何回滚代码"><a href="#拜托，不要再问我Git如何回滚代码" class="headerlink" title="拜托，不要再问我Git如何回滚代码"></a>拜托，不要再问我Git如何回滚代码</h1><p>这个是Git学习的第5篇内容，今天我们来讲讲Git如何做代码回滚。</p>
<h2 id="代码回滚"><a href="#代码回滚" class="headerlink" title="代码回滚"></a>代码回滚</h2><p>不知道大家在平常开发时中没有犯过这样一个错误，就是把IDE的配置或者项目运行的本地配置文件上传到服务器，导致别人更新代码之后，出现本地项目无法运行情况。</p>
<p>这是常见需要做代码回滚的一个场景，提交了一些我们不希望的文件。</p>
<p>我们也可能会碰到，在一次产品上线之后，出现了紧急Bug，一时半会无法修复，为了保证线上稳定，需要做代码回滚。</p>
<p>时光不能回退，Git却允许我们改变历史。</p>
<p>想要让Git回退历史，有以下步骤：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">使用git log命令，查看分支提交历史，确认需要回退的版本</span><br><span class="line">使用git reset --hard commit_id命令，进行版本回退</span><br><span class="line">使用git push origin命令，推送至远程分支</span><br></pre></td></tr></table></figure>

<p>快捷命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">回退上个版本：git reset --hard HEAD^ </span><br></pre></td></tr></table></figure>

<p>【注：HEAD是指向当前版本的指针，HEAD^表示上个版本,HEAD^^表示上上个版本】</p>
<p>如果修改到的文件比较少，我们可以不通过命令回滚的方式，手动删除之前的修改，再进行提交。</p>
<h2 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h2><p>一些时候，为了验证Bug，我们可能会直接在测试服务器上打断点调试。如果忘记去掉调试内容，在执行git pull更新时，Git会提示你提交修改。</p>
<p>此时，你可能已经不记得修改什么了，这个时候，我们可以用git checkout – file命令，来清空工作区的修改。是的，git checkout命令不仅可以用来切换分支，还能撤销文件修改。</p>
<p>如果想要撤销提交到暂存区后的文件内容怎么办呢(即执行git add之后)，我们可以使用git reset HEAD file命令撤销提交到暂存区的内容,再使用git checkout – file命令来撤销工作区的修改，需要分两步进行操作。</p>
<h2 id="reset还是revert"><a href="#reset还是revert" class="headerlink" title="reset还是revert?"></a>reset还是revert?</h2><p>针对评论区提出的，回滚是使用reset还是revert的疑问，这边做下补充说明。</p>
<p>reset和revert都可以用来回滚代码。但他们是有区别的，准确来说，reset是用来”回退”版本，而revert是用来”还原”某次或者某几次提交。</p>
<p>听起来有点绕，怎么去理解他们呢？</p>
<p>举个例子，比如在master分支，有以下提交历史:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">42eae13 (HEAD -&gt; master) 第四次修改</span><br><span class="line">97ea0f9 第三次修改</span><br><span class="line">e50b7c2 第二次修改</span><br><span class="line">3a52650 第一次修改</span><br></pre></td></tr></table></figure>

<p>可以看到，master最新版本为第四次修改。</p>
<p>如果发现，在第四次修改有错误，需要回滚到第三次修改，就可以用reset命令来回退。</p>
<p>执行 git reset –hard 97ea0f9,这个时候，git的提交历史变为:</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">97ea0f9 (HEAD -&gt; master) 第三次修改</span><br><span class="line">e50b7c2 第二次修改</span><br><span class="line">3a52650 第一次修改</span><br></pre></td></tr></table></figure>

<p>可以看到master当前指向97ea0f9这个版本，我们回到了第三次修改。</p>
<p>使用reset命令，Git会把要回退版本之后提交的修改都删除掉。要从第四次修改回退到第一次修改，那么会删除第二、三、四次的修改。【注：这里并不是真正的物理删除】</p>
<p>那如果发现第三次修改有错误，想要恢复第三次修改，却要保留第四次修改呢？</p>
<p>这个时候就可以用revert命令：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git revert -n 97ea0f9</span><br><span class="line">git commit -m &quot;恢复第三次修改&quot;</span><br></pre></td></tr></table></figure>

<p>Git提交历史会变成：</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">33b8b30 (HEAD -&gt; master) Revert &quot;恢复第三次修改&quot;</span><br><span class="line">42eae13 第四次修改</span><br><span class="line">97ea0f9 第三次修改</span><br><span class="line">e50b7c2 第二次修改</span><br><span class="line">3a52650 第一次修改</span><br></pre></td></tr></table></figure>

<p>实际上，Git把第三次修改从提交中剔除(还原)了，还保留了第四次修改，并且产生了新的commit_id。</p>
<p>在实际生产环境中，代码是基于master分支发布到线上的，会有多人进行提交。可能会碰到自己或团队其他成员开发的某个功能在上线之后有Bug,需要及时做代码回滚的操作。</p>
<p>在确认要回滚的版本之后，如果别人没有最新提交，那么就可以直接用reset命令进行版本回退，否则，就可以考虑使用revert命令进行还原修改，不能影响到别人的提交。</p>
<p>使用reset还是revert，需要考虑实际的适用场景，没有绝对化。</p>
<p>上面提的<em>并不是真正的物理删除</em>，是因为Git会把分支的每次修改记录都会保留下来，比如有某次的commit,某次的reset等。而使用git reflog show命令,可以查看完整的提交历史，</p>
<p>只要有commit_id，我们就能恢复任意版本的代码，在各版本之间来回穿梭。</p>
<p>以上，就是我对Git回滚代码的一些使用心得，个人观点,仅供参考。</p>
]]></content>
  </entry>
  <entry>
    <title>macos路由配置</title>
    <url>/2021/07/06/macos%E8%B7%AF%E7%94%B1%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h1 id="MacOS-上路由表的操作记录"><a href="#MacOS-上路由表的操作记录" class="headerlink" title="MacOS 上路由表的操作记录"></a>MacOS 上路由表的操作记录</h1><ol>
<li>查看路由表: <code>netstat -nr</code></li>
<li>添加路由: <code>sudo route add 34.0.7.0 34.0.7.1</code></li>
<li>删除路由: <code>sudo route delete 0.0.0.0</code></li>
<li>清空路由表: <code>networksetup -setadditionalroutes &quot;Ethernet&quot;</code>, “Ethernet” 指定路由走哪个设备（查看当前的设备可以使用这个命令 <code>networksetup -listallnetworkservices</code></li>
<li>清空路由表: <code>sudo route flush</code> , 是否有效没测试过,通过 <code>man route</code> 看到的,等哪天试过了,再来更新这个内容是否有效</li>
</ol>
<h3 id="无线网卡和-USB-有线网卡同时使用"><a href="#无线网卡和-USB-有线网卡同时使用" class="headerlink" title="无线网卡和 USB 有线网卡同时使用"></a>无线网卡和 USB 有线网卡同时使用</h3><p>我这里的使用场景是无线接外网, USB 网卡接内网,无线路由的网关是 192.168.0.1, USB 网卡的网关是 34.0.7.1</p>
<ol>
<li>删除默认路由: <code>sudo route delete 0.0.0.0</code></li>
<li>添加默认路由走无线网卡: <code>sudo route add 0.0.0.0 192.168.0.1</code></li>
<li>内网走 USB 网卡: <code>sudo route add 34.0.7.0 34.0.7.1</code></li>
<li>调整网络顺序,网络属性里面的多个网卡的优先级顺序问题。基本原则是哪个网卡访问互联网，他的优先级就在上面就可以了</li>
</ol>
<blockquote>
<p>有个问题没搞明白, 按逻辑说这样添加的静态路由是临时的,在重启后会消失失效,可实际上我重启了之后并没有失效</p>
</blockquote>
<h3 id="配置永久静态路由"><a href="#配置永久静态路由" class="headerlink" title="配置永久静态路由"></a>配置永久静态路由</h3><ol>
<li><code>networksetup</code> mac 自带的工具,升级到最新的Sierra后拥有,是个“系统偏好设置”中网络设置工具的终端版</li>
<li><code>networksetup –help</code> 可以查看具体的帮助</li>
<li>添加静态永久路由: <code>networksetup -setadditionalroutes &quot;USB 10/100/1000 LAN&quot; 10.188.12.0 255.255.255.0 192.168.8.254</code><br>“USB 10/100/1000 LAN” 指定路由走哪个设备（查看当前的设备可以使用这个命令 <code>networksetup -listallnetworkservices</code></li>
<li><code>netstat -nr</code> 查看路由表</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>python记忆点滴</title>
    <url>/2021/04/23/python%E8%AE%B0%E5%BF%86%E7%82%B9%E6%BB%B4/</url>
    <content><![CDATA[<h4 id="几个实用的库"><a href="#几个实用的库" class="headerlink" title="几个实用的库"></a>几个实用的库</h4><p><a href="https://docs.python.org/3/library/pathlib.html">pathlib</a>、<a href="https://docs.python.org/3/library/shlex.html#module-shlex"><code>shlex</code></a>、<a href="https://pypi.org/project/pdflatex/">pdflatex</a>、<a href="https://jeltef.github.io/PyLaTeX/current/examples/basic.html">pyLaTeX</a></p>
<a id="more"></a>]]></content>
      <categories>
        <category>python</category>
      </categories>
  </entry>
  <entry>
    <title>搜书方法记录</title>
    <url>/2021/04/24/%E6%90%9C%E4%B9%A6%E6%96%B9%E6%B3%95%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h4 id="IRC频道"><a href="#IRC频道" class="headerlink" title="IRC频道"></a>IRC频道</h4><p>有很多irc频道提供ebooks检索和推送.</p>
]]></content>
      <categories>
        <category>ebooks</category>
      </categories>
      <tags>
        <tag>ebooks</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/2021/06/08/%E9%94%99%E9%A2%98%E9%9B%86/</url>
    <content><![CDATA[<h4 id="英语"><a href="#英语" class="headerlink" title="英语"></a><strong>英语</strong></h4><ol>
<li>判断发音是否一致(T or F)：</li>
</ol>
<p>(  ) <u>au</u>tumn    h<u>or</u>se        (  ) squ<u>are</u>    h<u>ere</u></p>
<ol start="2">
<li><p>根据要求改变句子：</p>
<ol>
<li><p>They have some shapes.(改成否定句)</p>
<hr>
</li>
</ol>
</li>
<li><p>用所给单词的适当形式填空：</p>
<ol>
<li>This pair of glasses <strong>____</strong> (be) for grandma.</li>
<li>We like  <strong>____</strong> (swim) in summer.</li>
<li>We can <strong>____</strong> (plant) trees and we like <strong>____</strong> (have) a picnic in spring.</li>
<li>There <strong>____</strong> (be) some water in the glass.There isn’t <strong>____</strong> (some) bread.</li>
<li>Their friend <strong>____</strong> (have) some kites.<strong>____</strong> (that) kites are super.</li>
</ol>
</li>
</ol>
<h4 id="数学"><a href="#数学" class="headerlink" title="数学"></a><strong>数学</strong></h4><ol>
<li><p>递等计算：</p>
<p>343 - 98 + 157          694 - (194 + 34)             1000 ÷ 4 × 25</p>
</li>
</ol>
<p>   624 ÷ 4 × 2                2050 - 1981          525 + (387 - 225) + 313</p>
<p>   873 - 169 + 231     </p>
<ol start="2">
<li>列式计算：<ol>
<li>460减去60与5的积，差是多少？</li>
</ol>
</li>
</ol>
<ol start="3">
<li><p>填空题：</p>
<ol>
<li>14 × 35，用35十位上的3去乘14，得（    ）。</li>
<li>两位数乘两位数，积最大的是（   ）位数，积最小的是（    ）。</li>
<li>如果一艘轮船在江里行驶了20分钟，轮船的速度是80米/秒，那么这艘船行了（     ）米。</li>
</ol>
</li>
<li><p>选择题：</p>
<ol>
<li><p>下面四道算式中，积于其他三道不想等的是（    ）。</p>
<p>A. 12 × 70    B. 3 × 4 × 7 × 10   C. 7 × 12 × 100    D.2 × 6 × 7 × 10</p>
</li>
<li><p>两位数乘两位数，积是（    ）位数。</p>
<p>A. 三  B. 四  C.五或四  D.四或三</p>
</li>
</ol>
</li>
</ol>
<ol start="6">
<li>应用题：<ol>
<li>生产队买来800袋化肥，每袋50千克，用去3000千克，还剩多少吨</li>
</ol>
</li>
</ol>
<ol start="2">
<li>要挖一条3250米的隧道，已经挖好1570米，余下的5天挖好，平均每天挖多少米？</li>
</ol>
<ol start="3">
<li>花房种月季花146株，比牡丹花多54株，茉莉花是牡丹花的10倍，茉莉花有多少株？</li>
</ol>
<ol start="4">
<li>小胖家离体育馆4km，离篮球比赛还有15分钟。他会选择下列哪种方式去看球赛？</li>
</ol>
<p>   (1) 步行：速度是2米/秒       (2) 骑自行车：速度是250米/分</p>
<p>   (3) 出租车：速度是1500米/分    </p>
]]></content>
  </entry>
</search>
